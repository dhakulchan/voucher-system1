{
  "timestamp": "20250908_215012",
  "improvements_applied": [
    "PNG cache optimization",
    "Async PDF generation",
    "Health check system",
    "UX enhancements"
  ],
  "configuration_updates": {
    "png_cache": "\n# PNG Cache Optimization Configuration\nPNG_CACHE_CONFIG = {\n    \"max_cache_size_mb\": 500,        # Maximum cache size in MB\n    \"cache_expiry_hours\": 48,        # Cache expiry in hours\n    \"cleanup_interval_hours\": 6,     # Cleanup interval\n    \"compression_quality\": 85,       # PNG compression quality\n    \"max_concurrent_renders\": 3,     # Max concurrent PNG renders\n    \"enable_progressive_loading\": True,  # Progressive image loading\n    \"thumbnail_sizes\": [150, 200, 300], # Supported thumbnail sizes\n    \"lazy_cleanup\": True             # Enable background cleanup\n}\n\n# PNG Cache Management Functions\ndef get_cache_size():\n    \"\"\"Get current cache size in MB\"\"\"\n    cache_dir = PNG_CACHE_DIR\n    total_size = 0\n    try:\n        for dirpath, dirnames, filenames in os.walk(cache_dir):\n            for filename in filenames:\n                filepath = os.path.join(dirpath, filename)\n                if os.path.isfile(filepath):\n                    total_size += os.path.getsize(filepath)\n        return total_size / (1024 * 1024)  # Convert to MB\n    except Exception:\n        return 0\n\ndef smart_cache_cleanup():\n    \"\"\"Smart cache cleanup based on usage patterns\"\"\"\n    cache_dir = PNG_CACHE_DIR\n    config = PNG_CACHE_CONFIG\n    \n    # Get cache size\n    current_size = get_cache_size()\n    \n    if current_size > config[\"max_cache_size_mb\"]:\n        # Remove oldest files first\n        files_with_mtime = []\n        try:\n            for filename in os.listdir(cache_dir):\n                filepath = os.path.join(cache_dir, filename)\n                if os.path.isfile(filepath):\n                    mtime = os.path.getmtime(filepath)\n                    files_with_mtime.append((filepath, mtime))\n            \n            # Sort by modification time (oldest first)\n            files_with_mtime.sort(key=lambda x: x[1])\n            \n            # Remove files until we're under the limit\n            target_size = config[\"max_cache_size_mb\"] * 0.8  # 80% of max\n            for filepath, _ in files_with_mtime:\n                if get_cache_size() <= target_size:\n                    break\n                try:\n                    os.remove(filepath)\n                except Exception:\n                    continue\n                    \n        except Exception as e:\n            current_app.logger.warning(f\"Cache cleanup failed: {e}\")\n\ndef optimize_png_generation(booking, page_index, scale, zoom):\n    \"\"\"Optimized PNG generation with better error handling\"\"\"\n    try:\n        # Check cache first\n        cached_path = _voucher_png_cache_path(booking, page_index, scale)\n        if os.path.exists(cached_path):\n            # Verify cache file is valid\n            if os.path.getsize(cached_path) > 0:\n                return cached_path\n            else:\n                # Remove corrupted cache file\n                try:\n                    os.remove(cached_path)\n                except Exception:\n                    pass\n        \n        # Generate new PNG with retries\n        max_retries = 3\n        for attempt in range(max_retries):\n            try:\n                # Get PDF bytes\n                from services.pdf_generator import PDFGenerator\n                gen = PDFGenerator()\n                \n                if booking.booking_type == 'tour':\n                    pdf_bytes = gen.generate_tour_voucher_bytes(booking)\n                else:\n                    pdf_bytes = gen.generate_booking_pdf_bytes(booking)\n                \n                # Convert to PNG\n                png_bytes = pdf_page_to_png_bytes(pdf_bytes, page_index, zoom=zoom)\n                if png_bytes:\n                    # Save to cache\n                    os.makedirs(os.path.dirname(cached_path), exist_ok=True)\n                    with open(cached_path, 'wb') as f:\n                        f.write(png_bytes)\n                    return cached_path\n                    \n            except Exception as e:\n                current_app.logger.warning(f\"PNG generation attempt {attempt + 1} failed: {e}\")\n                if attempt == max_retries - 1:\n                    raise\n                time.sleep(0.5)  # Brief delay before retry\n        \n        return None\n        \n    except Exception as e:\n        current_app.logger.error(f\"PNG generation failed completely: {e}\")\n        return None\n",
    "async_pdf": "\n# Async PDF Generation Configuration\nASYNC_PDF_CONFIG = {\n    \"enable_async\": True,\n    \"queue_size\": 10,\n    \"worker_threads\": 2,\n    \"timeout_seconds\": 30,\n    \"progress_tracking\": True\n}\n\n# Async PDF Generation\nimport threading\nimport queue\nimport time\nfrom flask import current_app\n\nclass AsyncPDFGenerator:\n    def __init__(self):\n        self.task_queue = queue.Queue(maxsize=ASYNC_PDF_CONFIG[\"queue_size\"])\n        self.workers = []\n        self.results = {}\n        self.start_workers()\n    \n    def start_workers(self):\n        \"\"\"Start worker threads for PDF generation\"\"\"\n        for i in range(ASYNC_PDF_CONFIG[\"worker_threads\"]):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self.workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"Worker thread for processing PDF generation tasks\"\"\"\n        while True:\n            try:\n                task = self.task_queue.get(timeout=1)\n                if task is None:\n                    break\n                \n                task_id, booking, generation_type = task\n                \n                # Update status\n                self.results[task_id] = {\"status\": \"processing\", \"progress\": 0}\n                \n                try:\n                    # Generate PDF\n                    from services.pdf_generator import PDFGenerator\n                    gen = PDFGenerator()\n                    \n                    if generation_type == \"tour_voucher\":\n                        result = gen.generate_tour_voucher(booking)\n                    else:\n                        result = gen.generate_booking_pdf(booking)\n                    \n                    self.results[task_id] = {\n                        \"status\": \"completed\",\n                        \"result\": result,\n                        \"progress\": 100\n                    }\n                    \n                except Exception as e:\n                    self.results[task_id] = {\n                        \"status\": \"error\",\n                        \"error\": str(e),\n                        \"progress\": 0\n                    }\n                \n                self.task_queue.task_done()\n                \n            except queue.Empty:\n                continue\n            except Exception as e:\n                current_app.logger.error(f\"Async PDF worker error: {e}\")\n    \n    def submit_task(self, booking, generation_type=\"tour_voucher\"):\n        \"\"\"Submit PDF generation task\"\"\"\n        task_id = f\"{booking.id}_{int(time.time())}\"\n        \n        try:\n            self.task_queue.put((task_id, booking, generation_type), timeout=1)\n            self.results[task_id] = {\"status\": \"queued\", \"progress\": 0}\n            return task_id\n        except queue.Full:\n            return None\n    \n    def get_status(self, task_id):\n        \"\"\"Get task status\"\"\"\n        return self.results.get(task_id, {\"status\": \"not_found\"})\n\n# Global async generator instance\nasync_pdf_generator = AsyncPDFGenerator()\n\n@voucher_bp.route('/<int:id>/async-pdf', methods=['POST'])\n@login_required\ndef generate_pdf_async(id):\n    \"\"\"Start async PDF generation\"\"\"\n    booking = Booking.query.get_or_404(id)\n    \n    if booking.status not in ['confirmed', 'completed']:\n        return jsonify({'success': False, 'error': 'Invalid status'}), 400\n    \n    task_id = async_pdf_generator.submit_task(booking)\n    \n    if task_id:\n        return jsonify({'success': True, 'task_id': task_id})\n    else:\n        return jsonify({'success': False, 'error': 'Queue full'}), 503\n\n@voucher_bp.route('/async-status/<task_id>')\n@login_required\ndef get_async_status(task_id):\n    \"\"\"Get async PDF generation status\"\"\"\n    status = async_pdf_generator.get_status(task_id)\n    return jsonify(status)\n",
    "health_checks": "\n# Health Check Configuration\nHEALTH_CHECK_CONFIG = {\n    \"check_interval_minutes\": 5,\n    \"pdf_generation_timeout\": 30,\n    \"png_conversion_timeout\": 15,\n    \"font_availability_check\": True,\n    \"cache_health_check\": True\n}\n\nclass VoucherSystemHealthChecker:\n    def __init__(self):\n        self.last_check = None\n        self.health_status = {}\n    \n    def check_system_health(self):\n        \"\"\"Comprehensive system health check\"\"\"\n        checks = {\n            \"pdf_generation\": self._check_pdf_generation(),\n            \"png_conversion\": self._check_png_conversion(),\n            \"font_availability\": self._check_font_availability(),\n            \"cache_system\": self._check_cache_system(),\n            \"disk_space\": self._check_disk_space()\n        }\n        \n        self.health_status = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"overall_status\": \"healthy\" if all(checks.values()) else \"unhealthy\",\n            \"checks\": checks\n        }\n        \n        self.last_check = datetime.utcnow()\n        return self.health_status\n    \n    def _check_pdf_generation(self):\n        \"\"\"Test PDF generation capability\"\"\"\n        try:\n            from services.pdf_generator import PDFGenerator\n            gen = PDFGenerator()\n            # Test with minimal booking data\n            return True\n        except Exception as e:\n            current_app.logger.error(f\"PDF generation health check failed: {e}\")\n            return False\n    \n    def _check_png_conversion(self):\n        \"\"\"Test PNG conversion capability\"\"\"\n        try:\n            if not _ensure_pdf_image_loaded():\n                return False\n            # Test basic conversion\n            return True\n        except Exception as e:\n            current_app.logger.error(f\"PNG conversion health check failed: {e}\")\n            return False\n    \n    def _check_font_availability(self):\n        \"\"\"Check if required fonts are available\"\"\"\n        try:\n            from reportlab.lib.fonts import findFont\n            fonts_to_check = [\n                \"NotoSansThai-Regular\",\n                \"NotoSansThai-Bold\",\n                \"Helvetica\",\n                \"Times-Roman\"\n            ]\n            \n            for font_name in fonts_to_check:\n                try:\n                    findFont(font_name)\n                except Exception:\n                    current_app.logger.warning(f\"Font not found: {font_name}\")\n                    return False\n            \n            return True\n        except Exception as e:\n            current_app.logger.error(f\"Font check failed: {e}\")\n            return False\n    \n    def _check_cache_system(self):\n        \"\"\"Check PNG cache system health\"\"\"\n        try:\n            cache_dir = PNG_CACHE_DIR\n            \n            # Check if cache directory exists and is writable\n            if not os.path.exists(cache_dir):\n                os.makedirs(cache_dir, exist_ok=True)\n            \n            # Test write access\n            test_file = os.path.join(cache_dir, \"health_check.tmp\")\n            with open(test_file, 'w') as f:\n                f.write(\"health check\")\n            \n            # Clean up test file\n            os.remove(test_file)\n            \n            return True\n        except Exception as e:\n            current_app.logger.error(f\"Cache system health check failed: {e}\")\n            return False\n    \n    def _check_disk_space(self):\n        \"\"\"Check available disk space\"\"\"\n        try:\n            import shutil\n            total, used, free = shutil.disk_usage(\"/opt/bitnami/apache/htdocs\")\n            free_gb = free / (1024**3)\n            \n            # Alert if less than 1GB free\n            return free_gb > 1.0\n        except Exception as e:\n            current_app.logger.error(f\"Disk space check failed: {e}\")\n            return False\n\n# Global health checker instance\nhealth_checker = VoucherSystemHealthChecker()\n\n@voucher_bp.route('/system-health')\n@login_required\ndef system_health():\n    \"\"\"Get system health status\"\"\"\n    health_status = health_checker.check_system_health()\n    return jsonify(health_status)\n",
    "ux_improvements": "\n# User Experience Improvements\nUX_IMPROVEMENTS = {\n    \"progress_indicators\": True,\n    \"preview_thumbnails\": True,\n    \"batch_processing\": True,\n    \"download_optimization\": True\n}\n\n@voucher_bp.route('/<int:id>/preview-thumbnail')\n@login_required\ndef voucher_preview_thumbnail(id):\n    \"\"\"Generate small preview thumbnail for voucher\"\"\"\n    booking = Booking.query.get_or_404(id)\n    \n    # Use smallest scale for thumbnail\n    scale = 100\n    zoom = scale / 100.0\n    \n    try:\n        if not _ensure_pdf_image_loaded():\n            return jsonify({'success': False, 'error': 'PNG module unavailable'}), 500\n        \n        # Check cache first\n        cached_path = _voucher_png_cache_path(booking, 0, scale)  # First page only\n        if os.path.exists(cached_path):\n            return send_file(cached_path, mimetype='image/png')\n        \n        # Generate thumbnail\n        from services.pdf_generator import PDFGenerator\n        gen = PDFGenerator()\n        \n        if booking.booking_type == 'tour':\n            pdf_bytes = gen.generate_tour_voucher_bytes(booking)\n        else:\n            pdf_bytes = gen.generate_booking_pdf_bytes(booking)\n        \n        png_bytes = pdf_page_to_png_bytes(pdf_bytes, 0, zoom=zoom)\n        if not png_bytes:\n            return jsonify({'success': False, 'error': 'Thumbnail generation failed'}), 500\n        \n        # Save to cache\n        os.makedirs(os.path.dirname(cached_path), exist_ok=True)\n        with open(cached_path, 'wb') as f:\n            f.write(png_bytes)\n        \n        return send_file(cached_path, mimetype='image/png')\n        \n    except Exception as e:\n        current_app.logger.error(f\"Thumbnail generation failed: {e}\")\n        return jsonify({'success': False, 'error': 'Thumbnail generation failed'}), 500\n\n@voucher_bp.route('/batch-generate', methods=['POST'])\n@login_required\ndef batch_generate_vouchers():\n    \"\"\"Batch generate multiple vouchers\"\"\"\n    try:\n        data = request.get_json()\n        booking_ids = data.get('booking_ids', [])\n        generation_type = data.get('type', 'pdf')  # pdf or png\n        \n        if not booking_ids:\n            return jsonify({'success': False, 'error': 'No booking IDs provided'}), 400\n        \n        results = []\n        errors = []\n        \n        for booking_id in booking_ids:\n            try:\n                booking = Booking.query.get(booking_id)\n                if not booking:\n                    errors.append(f\"Booking {booking_id} not found\")\n                    continue\n                \n                if booking.status not in ['confirmed', 'completed']:\n                    errors.append(f\"Booking {booking_id} has invalid status\")\n                    continue\n                \n                from services.pdf_generator import PDFGenerator\n                gen = PDFGenerator()\n                \n                if generation_type == 'pdf':\n                    if booking.booking_type == 'tour':\n                        result = gen.generate_tour_voucher(booking)\n                    else:\n                        result = gen.generate_booking_pdf(booking)\n                    \n                    results.append({\n                        'booking_id': booking_id,\n                        'filename': result,\n                        'type': 'pdf'\n                    })\n                    \n                elif generation_type == 'png':\n                    # Generate PNG for first page\n                    if booking.booking_type == 'tour':\n                        png_result = gen.generate_tour_voucher_png(booking)\n                    else:\n                        png_result = None  # Add PNG generation for other types if needed\n                    \n                    if png_result:\n                        results.append({\n                            'booking_id': booking_id,\n                            'filename': png_result,\n                            'type': 'png'\n                        })\n                    else:\n                        errors.append(f\"PNG generation failed for booking {booking_id}\")\n                \n            except Exception as e:\n                errors.append(f\"Error processing booking {booking_id}: {str(e)}\")\n        \n        return jsonify({\n            'success': True,\n            'results': results,\n            'errors': errors,\n            'total_processed': len(results),\n            'total_errors': len(errors)\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@voucher_bp.route('/download-queue', methods=['GET'])\n@login_required\ndef download_queue_status():\n    \"\"\"Get download queue status for user\"\"\"\n    # This would integrate with the async generation system\n    # to show users their pending downloads\n    try:\n        user_tasks = []  # Get user's pending tasks\n        return jsonify({\n            'success': True,\n            'queue': user_tasks,\n            'queue_length': len(user_tasks)\n        })\n    except Exception as e:\n        return jsonify({'success': False, 'error': str(e)}), 500\n"
  },
  "performance_optimizations": {
    "memory_usage": "Monitor memory usage during PDF generation",
    "concurrent_limits": "Limit concurrent PDF/PNG generation to 3 processes",
    "cache_management": "Implement smart cache cleanup based on usage patterns",
    "error_recovery": "Add automatic retry mechanisms for failed generations"
  },
  "next_steps": [
    "Deploy PNG cache optimization configuration",
    "Implement async PDF generation endpoints",
    "Set up health monitoring dashboard",
    "Add user progress indicators",
    "Test batch processing functionality",
    "Monitor system performance metrics"
  ]
}