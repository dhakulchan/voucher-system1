from flask import Blueprint, render_template, request, redirect, url_for, flash, jsonify, make_response, send_file, Response
from utils.logging_config import get_logger
from flask_login import login_required, current_user
from models.customer import Customer
from models.booking import Booking
from extensions import db
from datetime import datetime, time
from services.booking_invoice import BookingInvoiceService
from services.booking_pdf_generator import BookingPDFGenerator
from services.public_share_service import PublicShareService
try:
    from services.quote_service import QuoteService
    QUOTE_SERVICE_AVAILABLE = True
except ImportError:
    QUOTE_SERVICE_AVAILABLE = False
    QuoteService = None
from utils.booking_utils import generate_booking_reference
from models.quote import Quote
import os
import json
import os
import random

booking_bp = Blueprint('booking', __name__)
logger = get_logger(__name__)

@booking_bp.route('/test/view/<int:booking_id>')
def test_view_booking(booking_id):
    """TEMPORARY: View booking without authentication for testing"""
    from flask import render_template
    from config import Config
    
    booking = Booking.query.get_or_404(booking_id)
    
    # Render the same template but without login requirement
    return render_template('booking/view_en.html', booking=booking, title=f'Booking {booking.booking_reference}', config=Config)

@booking_bp.route('/share/<int:id>')
def booking_view_public(id):
    """Public booking view with token authentication (30 days)"""
    booking = Booking.query.get_or_404(id)
    token = request.args.get('token', '')
    
    # Import token verification from voucher routes
    from flask import current_app
    secret = current_app.config.get('SECRET_KEY', '')
    
    if not secret:
        return jsonify({'success': False, 'message': 'Secret key not configured'}), 500
        
    # Use the same token verification as voucher routes
    from routes.voucher import _verify_voucher_image_token
    
    if not _verify_voucher_image_token(secret, token, booking):
        return jsonify({'success': False, 'message': 'Invalid or expired token'}), 403
    
    # Render public booking view template
    return render_template('booking/view_en.html', 
                         booking=booking, 
                         title=f'Booking {booking.booking_reference}',
                         is_public_view=True)

@booking_bp.route('/enhanced/<int:id>')
def enhanced_booking_view_public(id):
    """Public enhanced booking view with token authentication (30 days)"""
    booking = Booking.query.get_or_404(id)
    token = request.args.get('token', '')
    
    # Import token verification from voucher routes
    from flask import current_app
    secret = current_app.config.get('SECRET_KEY', '')
    
    if not secret:
        return jsonify({'success': False, 'message': 'Secret key not configured'}), 500
        
    # Use the same token verification as voucher routes
    from routes.voucher import _verify_voucher_image_token
    
    if not _verify_voucher_image_token(secret, token, booking):
        return jsonify({'success': False, 'message': 'Invalid or expired token'}), 403
    
    # Render enhanced booking view template
    return render_template('public/enhanced_booking_view.html', 
                         booking=booking, 
                         token=token,
                         title=f'Enhanced Booking View - {booking.booking_reference}',
                         is_public_view=True)

@booking_bp.route('/')
@booking_bp.route('/list')
@login_required
def list():
    """List all bookings"""
    # Get filter parameters
    status_filter = request.args.get('status', '')
    search = request.args.get('search', '')
    date_from = request.args.get('date_from', '')
    date_to = request.args.get('date_to', '')
    
    # Build query based on status filter
    if status_filter:
        if status_filter in ['pending', 'confirmed', 'cancelled', 'quoted', 'paid', 'vouchered', 'draft']:
            # Filter by specific status
            query = Booking.query.filter(Booking.status == status_filter)
        else:
            # Unknown status, show all
            query = Booking.query
    else:
        # Check if this is a form submission with empty status (All Statuses selected)
        if 'status' in request.args:
            # User explicitly selected "All Statuses" - show all
            query = Booking.query
        else:
            # Default visit (no status parameter) - show pending, confirmed, and draft
            query = Booking.query.filter(Booking.status.in_(['pending', 'confirmed', 'draft']))
    
    if search:
        # Import Quote model for searching
        try:
            from models.quote import Quote
            # Get booking IDs that have quotes matching the search term
            quote_booking_ids = db.session.query(Quote.booking_id).filter(
                Quote.quote_number.contains(search)
            ).subquery()
            
            query = query.join(Customer).filter(
                db.or_(
                    Customer.first_name.contains(search),
                    Customer.last_name.contains(search),
                    Customer.email.contains(search),
                    Booking.booking_reference.contains(search),
                    Booking.quote_number.contains(search),
                    Booking.guest_list.contains(search),
                    Booking.id.in_(quote_booking_ids)
                )
            )
        except ImportError:
            # Fallback if Quote model not available
            query = query.join(Customer).filter(
                db.or_(
                    Customer.first_name.contains(search),
                    Customer.last_name.contains(search),
                    Customer.email.contains(search),
                    Booking.booking_reference.contains(search),
                    Booking.quote_number.contains(search),
                    Booking.guest_list.contains(search)
                )
            )
    
    if date_from:
        try:
            date_from_obj = datetime.strptime(date_from, '%Y-%m-%d').date()
            query = query.filter(Booking.arrival_date >= date_from_obj)
        except ValueError:
            pass
    
    if date_to:
        try:
            date_to_obj = datetime.strptime(date_to, '%Y-%m-%d').date()
            query = query.filter(Booking.departure_date <= date_to_obj)
        except ValueError:
            pass
    
    bookings = query.order_by(Booking.created_at.desc()).all()
    
    # Calculate statistics for all status types
    stats = {
        'pending': Booking.query.filter_by(status='pending').count(),
        'confirmed': Booking.query.filter_by(status='confirmed').count(),
        'completed': Booking.query.filter_by(status='completed').count(),
        'cancelled': Booking.query.filter_by(status='cancelled').count(),
        'draft': Booking.query.filter_by(status='draft').count(),
        'quoted': Booking.query.filter_by(status='quoted').count(),
        'invoiced': Booking.query.filter_by(status='invoiced').count(),
        'paid': Booking.query.filter_by(status='paid').count(),
        'vouchered': Booking.query.filter_by(status='vouchered').count()
    }
    
    # Use language-specific template
    from flask import session
    current_language = session.get('language', 'en')
    template_name = f'booking/list_{current_language}.html'
    
    # Fallback to English template if language-specific template doesn't exist
    try:
        return render_template(template_name, bookings=bookings, stats=stats)
    except:
        return render_template('booking/list_en.html', bookings=bookings, stats=stats)

@booking_bp.route('/customers', methods=['GET', 'POST'])
@login_required
def customers():
    """List all customers"""
    if request.method == 'POST':
        try:
            customer = Customer(
                first_name=request.form.get('first_name'),
                last_name=request.form.get('last_name'),
                email=request.form.get('email'),
                phone=request.form.get('phone'),
                nationality=request.form.get('nationality'),
                notes=request.form.get('notes'),
                name=''  # sync later
            )
            customer.sync_name()
            db.session.add(customer)
            db.session.commit()
            flash('‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success')
            return redirect(url_for('booking.customers'))
        except Exception as e:
            db.session.rollback()
            flash(f'‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤: {str(e)}', 'error')
    
    search = request.args.get('search', '')
    query = Customer.query
    if search:
        like = f"%{search}%"
        # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ô name / first_name / last_name / email / phone
        query = query.filter(db.or_(
            Customer.name.like(like),
            Customer.first_name.like(like),
            Customer.last_name.like(like),
            Customer.email.like(like),
            Customer.phone.like(like)
        ))
    customers = query.order_by(Customer.created_at.desc()).all()
    return render_template('customer/list.html', customers=customers)

@booking_bp.route('/create', methods=['GET', 'POST'])
@login_required
def create():
    """Create a new booking"""
    if request.method == 'POST':
        try:
            # Get form data
            customer_id = request.form.get('customer_id')
            booking_type = request.form.get('booking_type')
            
            # Get or create customer
            if customer_id:
                customer = Customer.query.get(customer_id)
            else:
                # Create new customer (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö first/last name)
                first_name = request.form.get('customer_first_name') or request.form.get('first_name') or ''
                last_name = request.form.get('customer_last_name') or request.form.get('last_name') or ''
                email = request.form.get('customer_email') or request.form.get('email')
                phone = request.form.get('customer_phone') or request.form.get('phone')
                address = request.form.get('customer_address') or request.form.get('address')
                customer = Customer(
                    first_name=first_name.strip() or None,
                    last_name=last_name.strip() or None,
                    email=email,
                    phone=phone,
                    address=address,
                    name=''  # will sync
                )
                customer.sync_name()
                db.session.add(customer)
                db.session.flush()  # Get customer ID

            # Skip Invoice Ninja integration (removed)
            
            # Create booking
            booking = Booking(
                customer_id=customer.id,
                booking_reference=generate_booking_reference(),
                booking_type=booking_type,
                created_by=current_user.id
            )
            
            # Common fields
            if request.form.get('arrival_date'):
                booking.arrival_date = datetime.strptime(request.form.get('arrival_date'), '%Y-%m-%d').date()
            if request.form.get('departure_date'):
                booking.departure_date = datetime.strptime(request.form.get('departure_date'), '%Y-%m-%d').date()
            if request.form.get('traveling_period_start'):
                booking.traveling_period_start = datetime.strptime(request.form.get('traveling_period_start'), '%Y-%m-%d').date()
            if request.form.get('traveling_period_end'):
                booking.traveling_period_end = datetime.strptime(request.form.get('traveling_period_end'), '%Y-%m-%d').date()
            
            # Time and deadline fields - time_limit is required
            time_limit_str = request.form.get('time_limit')
            if not time_limit_str:
                flash('Time Limit is required', 'error')
                return redirect(url_for('booking.create'))
            
            try:
                booking.time_limit = datetime.strptime(time_limit_str, '%Y-%m-%dT%H:%M')
            except ValueError:
                flash('Invalid Time Limit format', 'error')
                return redirect(url_for('booking.create'))
                
            if request.form.get('due_date'):
                booking.due_date = datetime.strptime(request.form.get('due_date'), '%Y-%m-%d').date()
            
            booking.adults = int(request.form.get('adults', 1))
            booking.children = int(request.form.get('children', 0))
            booking.total_pax = int(request.form.get('total_pax', 1))
            booking.infants = int(request.form.get('infants', 0))
            booking.total_amount = float(request.form.get('total_amount', 0))
            
            # New fields
            booking.party_name = request.form.get('party_name', '').strip()
            booking.description = request.form.get('description', '').strip()
            
            # Flight info - convert line breaks to HTML
            flight_info = request.form.get('flight_info', '').strip()
            if flight_info:
                # Convert line breaks to <br> tags and wrap in <p> if not already wrapped
                flight_info = flight_info.replace('\r\n', '\n').replace('\r', '\n')
                flight_info = flight_info.replace('\n', '<br>')
                if not flight_info.startswith('<p>'):
                    flight_info = f'<p>{flight_info}</p>'
                booking.flight_info = flight_info
            else:
                booking.flight_info = None
            
            # Admin and Management fields
            admin_notes_raw = request.form.get('admin_notes', '')
            manager_memos_raw = request.form.get('manager_memos', '')
            internal_note_raw = request.form.get('internal_note', '')
            
            print(f"CREATE FORM DEBUG admin_notes='{admin_notes_raw}' manager_memos='{manager_memos_raw}' internal_note='{internal_note_raw}'")
            logger.info(f"CREATE FORM DEBUG admin_notes='{admin_notes_raw}' manager_memos='{manager_memos_raw}' internal_note='{internal_note_raw}'")
            
            booking.admin_notes = admin_notes_raw.strip() or None
            booking.manager_memos = manager_memos_raw.strip() or None
            booking.internal_note = internal_note_raw.strip() or None
            
            print(f"Saving admin_notes='{booking.admin_notes}' manager_memos='{booking.manager_memos}' internal_note='{booking.internal_note}'")
            logger.info(f"Saving admin_notes='{booking.admin_notes}' manager_memos='{booking.manager_memos}' internal_note='{booking.internal_note}'")
            # Save special request for ALL types (previously only hotel)
            booking.special_request = (request.form.get('special_request') or request.form.get('special_requests') or '').strip() or None
            
            # Guest list (HTML from TinyMCE)
            guest_list_html = request.form.get('guest_list')
            if guest_list_html is not None:
                # Convert textarea input back to list format
                lines = [line.strip() for line in guest_list_html.split('\n') if line.strip()]
                if lines:
                    booking.set_guest_list(lines)
                else:
                    booking.guest_list = None
                logger.debug("Set guest list from textarea (create): %r -> %r", guest_list_html, lines)
            
            # Pickup information for ALL booking types (not just transport)
            booking.pickup_point = request.form.get('pickup_point', '').strip() or None
            if request.form.get('pickup_time'):
                try:
                    booking.pickup_time = datetime.strptime(request.form.get('pickup_time'), '%H:%M').time()
                except ValueError:
                    pass  # Invalid time format, skip
            
            # Products & Calculation data
            products = []
            product_names = request.form.getlist('products[0][name]') + request.form.getlist('products[1][name]') + request.form.getlist('products[2][name]') + request.form.getlist('products[3][name]') + request.form.getlist('products[4][name]') + request.form.getlist('products[5][name]') + request.form.getlist('products[6][name]') + request.form.getlist('products[7][name]') + request.form.getlist('products[8][name]') + request.form.getlist('products[9][name]')
            product_quantities = request.form.getlist('products[0][quantity]') + request.form.getlist('products[1][quantity]') + request.form.getlist('products[2][quantity]') + request.form.getlist('products[3][quantity]') + request.form.getlist('products[4][quantity]') + request.form.getlist('products[5][quantity]') + request.form.getlist('products[6][quantity]') + request.form.getlist('products[7][quantity]') + request.form.getlist('products[8][quantity]') + request.form.getlist('products[9][quantity]')
            product_prices = request.form.getlist('products[0][price]') + request.form.getlist('products[1][price]') + request.form.getlist('products[2][price]') + request.form.getlist('products[3][price]') + request.form.getlist('products[4][price]') + request.form.getlist('products[5][price]') + request.form.getlist('products[6][price]') + request.form.getlist('products[7][price]') + request.form.getlist('products[8][price]') + request.form.getlist('products[9][price]')
            product_amounts = request.form.getlist('products[0][amount]') + request.form.getlist('products[1][amount]') + request.form.getlist('products[2][amount]') + request.form.getlist('products[3][amount]') + request.form.getlist('products[4][amount]') + request.form.getlist('products[5][amount]') + request.form.getlist('products[6][amount]') + request.form.getlist('products[7][amount]') + request.form.getlist('products[8][amount]') + request.form.getlist('products[9][amount]')
            
            # Better approach: iterate through form data to find products
            products = []
            form_data = request.form.to_dict(flat=False)
            
            # Extract products from dynamic form data
            i = 0
            while True:
                name_key = f'products[{i}][name]'
                quantity_key = f'products[{i}][quantity]'
                price_key = f'products[{i}][price]'
                amount_key = f'products[{i}][amount]'
                
                if name_key not in form_data:
                    break
                    
                name = form_data[name_key][0] if form_data[name_key] else ''
                quantity = form_data[quantity_key][0] if quantity_key in form_data and form_data[quantity_key] else '1'
                price = form_data[price_key][0] if price_key in form_data and form_data[price_key] else '0'
                amount = form_data[amount_key][0] if amount_key in form_data and form_data[amount_key] else '0'
                
                if name.strip():  # Only add products with names
                    products.append({
                        'name': name.strip(),
                        'quantity': int(quantity) if quantity else 1,
                        'price': float(price) if price else 0.0,
                        'amount': float(amount) if amount else 0.0
                    })
                
                i += 1
            
            if products:
                booking.set_products(products)
            
            # Type-specific fields
            if booking_type == 'hotel':
                booking.agency_reference = request.form.get('agency_reference')
                booking.hotel_name = request.form.get('hotel_name')
                booking.room_type = request.form.get('room_type')
                # (special_request already handled globally)
            elif booking_type == 'transport':
                # Additional transport-specific fields (pickup already handled globally)
                booking.destination = request.form.get('destination')
                booking.vehicle_type = request.form.get('vehicle_type')
            elif booking_type == 'tour':
                # Daily services list only for tour (legacy)
                services = []
                service_dates = request.form.getlist('service_dates[]')
                service_descriptions = request.form.getlist('service_descriptions[]')
                service_types = request.form.getlist('service_types[]')
                for i in range(len(service_dates)):
                    if service_dates[i] and service_descriptions[i]:
                        services.append({
                            'date': service_dates[i],
                            'description': service_descriptions[i],
                            'type': service_types[i] if i < len(service_types) else ''
                        })
                booking.set_daily_services(services)
            
            db.session.add(booking)
            db.session.commit()
            
            flash(f'Booking {booking.booking_reference} created successfully!', 'success')
            return redirect(url_for('booking.view', id=booking.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error creating booking: {str(e)}', 'error')
    
    # Get customers for dropdown (‡πÉ‡∏ä‡πâ full_name ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
    customers = Customer.query.order_by(Customer.name).all()
    
    # Language-aware template selection
    from flask import session
    current_language = session.get('language', 'en')
    template_name = f'booking/create_{current_language}.html'
    
    # Fallback to default template if language-specific doesn't exist
    try:
        return render_template(template_name, customers=customers)
    except:
        return render_template('booking/create.html', customers=customers)

@booking_bp.route('/view/<int:id>')
@login_required
def view(id):
    """View booking details"""
    from flask import session, current_app as app
    app.logger.info(f"üîç Loading booking {id}")
    
    try:
        # Debug: Check database directly first
        raw_result = db.session.execute(db.text("SELECT id, quote_number, quote_id FROM bookings WHERE id = :id"), {"id": id}).fetchone()
        if raw_result:
            app.logger.info(f"üìã Raw SQL result: id={raw_result[0]}, quote_number={raw_result[1]}, quote_id={raw_result[2]}")
        else:
            app.logger.error(f"‚ùå No raw SQL result for booking {id}")
            
        booking = Booking.query.get_or_404(id)
        app.logger.info(f"üìã Booking {id} loaded: quote_number={booking.quote_number}, quote_id={booking.quote_id}")
        
        # Load quotes relationship explicitly
        quotes_count = len(booking.quotes)
        app.logger.info(f"üìù Booking {id} has {quotes_count} quotes")
        if quotes_count > 0:
            latest_quote = booking.quotes[-1]
            app.logger.info(f"üìù Latest quote: {latest_quote.quote_number} (ID: {latest_quote.id})")
        
        # Refresh booking data from database to ensure latest values
        try:
            db.session.refresh(booking)
            app.logger.info(f"üîÑ After refresh: quote_number={booking.quote_number}, quote_id={booking.quote_id}")
        except Exception as refresh_error:
            app.logger.warning(f"‚ö†Ô∏è Refresh failed: {refresh_error}, continuing without refresh")
            
    except Exception as e:
        app.logger.error(f"‚ùå Error loading booking {id}: {e}")
        raise

    # Sync AR/QT numbers from Invoice Ninja so UI and PDFs show latest
    invoice_status = None
    try:
        bis = BookingInvoiceService()
        if bis.sync_booking_numbers(booking):
            db.session.commit()
    except Exception as e:
        # Non-fatal; continue rendering even if sync fails
        pass
    
    # Use language-specific template
    current_language = session.get('language', 'en')
    template_name = f'booking/view_{current_language}.html'
    
    # Import config for template
    from config import Config
    
    # Fallback to English template if language-specific template doesn't exist
    try:
        app.logger.info(f"üé® Attempting to render template: {template_name}")
        response = make_response(render_template(template_name, booking=booking, invoice_status=invoice_status, config=Config))
        app.logger.info(f"‚úÖ Successfully rendered template: {template_name}")
    except Exception as template_error:
        app.logger.error(f"‚ùå Template rendering failed for {template_name}: {template_error}")
        try:
            app.logger.info(f"üîÑ Falling back to English template")
            response = make_response(render_template('booking/view_en.html', booking=booking, invoice_status=invoice_status, config=Config))
            app.logger.info(f"‚úÖ Successfully rendered fallback template")
        except Exception as fallback_error:
            app.logger.error(f"‚ùå Fallback template rendering also failed: {fallback_error}")
            import traceback
            app.logger.error(f"üìç Full traceback: {traceback.format_exc()}")
            raise
    
    # Add cache control headers to prevent browser caching of dynamic content
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    
    return response

@booking_bp.route('/<int:id>/update-status', methods=['POST'])
@login_required
def update_status(id):
    """Update booking status"""
    booking = Booking.query.get_or_404(id)
    
    new_status = request.form.get('status')
    if new_status in ['pending', 'confirmed', 'completed', 'cancelled']:
        booking.status = new_status
        
        if new_status == 'confirmed':
            flash('‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß', 'success')
        elif new_status == 'completed':
            flash('‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß', 'success')
        elif new_status == 'cancelled':
            flash('‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÅ‡∏•‡πâ‡∏ß', 'warning')
        
        db.session.commit()
    else:
        flash('‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', 'error')
    
    return redirect(url_for('booking.view', id=id))

# Invoice Ninja sync function removed

@booking_bp.route('/<int:booking_id>/mark-paid', methods=['POST'])
@login_required
def mark_as_paid(booking_id):
    """Mark booking invoice as paid with password confirmation"""
    
    try:
        password = request.form.get('payment_password')
        
        # Verify password
        if password != 'pm250966':
            flash('‚ùå Invalid password. Access denied.', 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        booking = Booking.query.get_or_404(booking_id)
        
        # Get form data for quote, invoice numbers and status
        new_quote_number = request.form.get('quote_number', '').strip()
        new_invoice_number = request.form.get('invoice_number', '').strip()
        new_invoice_status = request.form.get('invoice_status', '').strip()
        maintain_paid_status = request.form.get('maintain_paid_status', '') == 'true'
        
        # Update quote and invoice data if provided
        old_quote = booking.quote_number
        old_invoice = booking.invoice_number
        old_status = booking.invoice_status
        
        if new_quote_number:
            booking.quote_number = new_quote_number
        if new_invoice_number:
            booking.invoice_number = new_invoice_number
        if new_invoice_status:
            booking.invoice_status = new_invoice_status
        
        # Check if booking has invoice number after update
        if not booking.invoice_number:
            flash('‚ùå No invoice number provided. Please enter invoice number.', 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Set payment status
        if maintain_paid_status:
            # Confirming already paid status - maintain current paid state
            booking.is_paid = True
            if not booking.invoice_paid_date:
                booking.invoice_paid_date = datetime.now()
            # Use the provided status (default to 'paid' from form)
            if not booking.invoice_status:
                booking.invoice_status = 'paid'
        else:
            # New payment marking - always mark as paid
            booking.invoice_status = 'paid'
            booking.is_paid = True
            booking.invoice_paid_date = datetime.now()
        
        db.session.commit()
        
        action_type = "confirmed" if maintain_paid_status else "marked"
        logger.info(f"Booking {booking_id} {action_type} as paid by admin {current_user.username}")
        
        # Build success message
        success_msgs = []
        if old_quote != booking.quote_number:
            success_msgs.append(f'Quote: {old_quote or "None"} ‚Üí {booking.quote_number}')
        if old_invoice != booking.invoice_number:
            success_msgs.append(f'Invoice: {old_invoice or "None"} ‚Üí {booking.invoice_number}')
        
        if maintain_paid_status:
            flash(f'‚úÖ Payment status confirmed! Invoice {booking.invoice_number} status: {booking.invoice_status.upper()}. Voucher creation enabled.', 'success')
        else:
            flash(f'‚úÖ Invoice {booking.invoice_number} marked as PAID! Voucher creation is now available.', 'success')
            
        flash(f'üîÑ Status updated: {old_status or "Unknown"} ‚Üí {booking.invoice_status.upper()}', 'info')
        
        if success_msgs:
            flash(f'üìù Updated: {", ".join(success_msgs)}', 'info')
        
        return redirect(url_for('booking.view', id=booking_id))
        
    except Exception as e:
        logger.error(f"Error marking booking {booking_id} as paid: {e}")
        flash('An error occurred while marking as paid.', 'error')
        return redirect(url_for('booking.view', id=booking_id))

@booking_bp.route('/<int:booking_id>/unmark-paid', methods=['POST'])
@login_required
def unmark_as_paid(booking_id):
    """Unmark booking invoice as paid (reset to unpaid) with password confirmation"""
    
    try:
        password = request.form.get('payment_password')
        
        # Verify password
        if password != 'pm250966':
            flash('‚ùå Invalid password. Access denied.', 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        booking = Booking.query.get_or_404(booking_id)
        
        # Get form data for new status and values
        new_quote_number = request.form.get('quote_number', '').strip()
        new_invoice_number = request.form.get('invoice_number', '').strip()
        new_invoice_status = request.form.get('invoice_status', '').strip()
        
        # Store old values for logging
        old_quote = booking.quote_number
        old_invoice = booking.invoice_number
        old_status = booking.invoice_status
        
        # Update fields if provided
        if new_quote_number:
            booking.quote_number = new_quote_number
        if new_invoice_number:
            booking.invoice_number = new_invoice_number
            
        # Set invoice status - default to "unknown" if not specified
        if new_invoice_status:
            booking.invoice_status = new_invoice_status
        else:
            booking.invoice_status = 'unknown'
        
        # Reset payment status
        booking.is_paid = False
        booking.invoice_paid_date = None
        
        db.session.commit()
        
        logger.info(f"Booking {booking_id} unmarked as paid by admin {current_user.username}")
        
        # Build success message
        success_msgs = []
        if old_quote != booking.quote_number:
            success_msgs.append(f'Quote: {old_quote or "None"} ‚Üí {booking.quote_number}')
        if old_invoice != booking.invoice_number:
            success_msgs.append(f'Invoice: {old_invoice or "None"} ‚Üí {booking.invoice_number}')
        
        flash(f'‚úÖ Payment status reset! Invoice {booking.invoice_number or "N/A"} is now unpaid.', 'success')
        flash(f'üîÑ Status updated: {old_status or "Unknown"} ‚Üí {booking.invoice_status.upper()}', 'info')
        
        if success_msgs:
            flash(f'üìù Updated: {", ".join(success_msgs)}', 'info')
        
        return redirect(url_for('booking.view', id=booking_id))
        
    except Exception as e:
        logger.error(f"Error unmarking booking {booking_id} as paid: {e}")
        flash('An error occurred while resetting payment status.', 'error')
        return redirect(url_for('booking.view', id=booking_id))

# Bulk invoice sync function removed

@booking_bp.route('/edit/<int:id>', methods=['GET', 'POST'])
@login_required
def edit(id):
    """Edit booking"""
    booking = Booking.query.get_or_404(id)
    
    if request.method == 'POST':
        try:
            # Update booking fields
            booking.booking_type = request.form.get('booking_type') or booking.booking_type
            booking.status = request.form.get('status') or booking.status
            
            # Update dates
            if request.form.get('arrival_date'):
                booking.arrival_date = datetime.strptime(request.form.get('arrival_date'), '%Y-%m-%d').date()
            if request.form.get('departure_date'):
                booking.departure_date = datetime.strptime(request.form.get('departure_date'), '%Y-%m-%d').date()
            if request.form.get('traveling_period_start'):
                booking.traveling_period_start = datetime.strptime(request.form.get('traveling_period_start'), '%Y-%m-%d').date()
            if request.form.get('traveling_period_end'):
                booking.traveling_period_end = datetime.strptime(request.form.get('traveling_period_end'), '%Y-%m-%d').date()
            
            # Time and deadline fields - time_limit is required
            time_limit_str = request.form.get('time_limit')
            if not time_limit_str:
                flash('Time Limit is required', 'error')
                return redirect(url_for('booking.edit', id=booking.id))
            
            try:
                booking.time_limit = datetime.strptime(time_limit_str, '%Y-%m-%dT%H:%M')
            except ValueError:
                flash('Invalid Time Limit format', 'error')
                return redirect(url_for('booking.edit', id=booking.id))
                
            if request.form.get('due_date'):
                booking.due_date = datetime.strptime(request.form.get('due_date'), '%Y-%m-%d').date()
            elif request.form.get('due_date') == '':
                booking.due_date = None
            
            # Pax
            booking.adults = int(request.form.get('adults', booking.adults or 1))
            booking.children = int(request.form.get('children', booking.children or 0))
            booking.total_pax = int(request.form.get('total_pax', (booking.adults or 0) + (booking.children or 0) or 1))
            booking.infants = int(request.form.get('infants', booking.infants or 0))
            
            # Financial
            if request.form.get('total_amount'):
                try:
                    booking.total_amount = float(request.form.get('total_amount'))
                except ValueError:
                    pass
            
            # Common fields
            booking.party_name = (request.form.get('party_name') or booking.party_name or '').strip()
            # WYSIWYG description (may contain HTML)
            if 'description' in request.form:
                booking.description = request.form.get('description').strip()
            booking.internal_note = request.form.get('internal_note', '').strip() or None
            
            # Flight info - convert line breaks to HTML
            flight_info = request.form.get('flight_info', '').strip()
            if flight_info:
                # Convert line breaks to <br> tags and wrap in <p> if not already wrapped
                flight_info = flight_info.replace('\r\n', '\n').replace('\r', '\n')
                flight_info = flight_info.replace('\n', '<br>')
                if not flight_info.startswith('<p>'):
                    flight_info = f'<p>{flight_info}</p>'
                booking.flight_info = flight_info
            else:
                booking.flight_info = None
            # Admin and Management fields
            logger.debug("EDIT FORM DEBUG admin_notes=%r manager_memos=%r internal_note=%r", 
                         request.form.get('admin_notes'),
                         request.form.get('manager_memos'),
                         request.form.get('internal_note'))
            
            booking.admin_notes = request.form.get('admin_notes', '').strip() or None
            booking.manager_memos = request.form.get('manager_memos', '').strip() or None
            
            logger.debug("Saving admin_notes=%r manager_memos=%r", booking.admin_notes, booking.manager_memos)
            
            # DEBUG: Log form data for guest_list and special_request
            logger.debug("EDIT FORM DEBUG guest_list=%r special_request=%r", 
                         request.form.get('guest_list'),
                         request.form.get('special_request'))
            
            # Persist special request for ALL booking types
            booking.special_request = (request.form.get('special_request') or request.form.get('special_requests') or '').strip() or None
            
            # Guest list (textarea with one per line)
            guest_list_html = request.form.get('guest_list')
            if guest_list_html is not None:
                # Convert textarea input back to list format
                lines = [line.strip() for line in guest_list_html.split('\n') if line.strip()]
                if lines:
                    booking.set_guest_list(lines)
                else:
                    booking.guest_list = None
                logger.debug("Set guest list from textarea: %r -> %r", guest_list_html, lines)
            
            # Pickup information for ALL booking types (not just transport)
            booking.pickup_point = request.form.get('pickup_point', '').strip() or None
            if request.form.get('pickup_time'):
                try:
                    booking.pickup_time = datetime.strptime(request.form.get('pickup_time'), '%H:%M').time()
                except ValueError:
                    pass  # Invalid time format, skip
            elif request.form.get('pickup_time') == '':
                booking.pickup_time = None
            
            # Products & Calculation data
            products = []
            form_data = request.form.to_dict(flat=False)
            
            # Extract products from dynamic form data
            i = 0
            while True:
                name_key = f'products[{i}][name]'
                quantity_key = f'products[{i}][quantity]'
                price_key = f'products[{i}][price]'
                amount_key = f'products[{i}][amount]'
                
                if name_key not in form_data:
                    break
                    
                name = form_data[name_key][0] if form_data[name_key] else ''
                quantity = form_data[quantity_key][0] if quantity_key in form_data and form_data[quantity_key] else '1'
                price = form_data[price_key][0] if price_key in form_data and form_data[price_key] else '0'
                amount = form_data[amount_key][0] if amount_key in form_data and form_data[amount_key] else '0'
                
                if name.strip():  # Only add products with names
                    products.append({
                        'name': name.strip(),
                        'quantity': int(quantity) if quantity else 1,
                        'price': float(price) if price else 0.0,
                        'amount': float(amount) if amount else 0.0
                    })
                
                i += 1
            
            # Always update products (even if empty)
            booking.set_products(products)
            
            # Type-specific & shared optional fields
            if booking.booking_type == 'hotel':
                booking.agency_reference = request.form.get('agency_reference') or booking.agency_reference
                booking.hotel_name = request.form.get('hotel_name') or booking.hotel_name
                booking.room_type = request.form.get('room_type') or booking.room_type
                # (special_request already set globally)
            elif booking.booking_type == 'transport':
                # Additional transport-specific fields (pickup already handled globally)
                booking.destination = request.form.get('destination') or booking.destination
                booking.vehicle_type = request.form.get('vehicle_type') or booking.vehicle_type
            elif booking.booking_type == 'tour':
                # Daily services list only for tour (legacy)
                services = []
                service_dates = request.form.getlist('service_dates[]')
                service_descriptions = request.form.getlist('service_descriptions[]')
                service_types = request.form.getlist('service_types[]')
                for i in range(len(service_dates)):
                    if service_dates[i] and service_descriptions[i]:
                        services.append({
                            'date': service_dates[i],
                            'description': service_descriptions[i],
                            'type': service_types[i] if i < len(service_types) else ''
                        })
                if services:
                    booking.set_daily_services(services)
            
            db.session.commit()
            flash('Booking updated successfully!', 'success')
            return redirect(url_for('booking.view', id=booking.id))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating booking: {str(e)}', 'error')
    
    return render_template('booking/edit.html', booking=booking)

@booking_bp.route('/delete/<int:id>', methods=['POST'])
@login_required
def delete(id):
    """Delete booking"""
    booking = Booking.query.get_or_404(id)
    
    try:
        db.session.delete(booking)
        db.session.commit()
        flash(f'Booking {booking.booking_reference} deleted successfully!', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting booking: {str(e)}', 'error')
    
    return redirect(url_for('dashboard.bookings'))

@booking_bp.route('/ro/<int:id>')
@login_required
def ro_pdf(id):
    """Generate Hotel RO PDF"""
    booking = Booking.query.get_or_404(id)
    
    if booking.booking_type != 'hotel':
        flash('This booking is not a hotel reservation', 'error')
        return redirect(url_for('booking.view', id=id))
    
    from services.pdf_generator import PDFGenerator
    pdf_generator = PDFGenerator()
    
    try:
        pdf_path = pdf_generator.generate_hotel_ro(booking)
        return redirect(f'/static/generated/{pdf_path}')
    except Exception as e:
        flash(f'Error generating RO PDF: {str(e)}', 'error')
        return redirect(url_for('booking.view', id=id))

@booking_bp.route('/mpv/<int:id>')
@login_required
def mpv_pdf(id):
    """Generate MPV Booking PDF"""
    booking = Booking.query.get_or_404(id)
    
    if booking.booking_type != 'transport':
        flash('This booking is not a transport reservation', 'error')
        return redirect(url_for('booking.view', id=id))
    
    from services.pdf_generator import PDFGenerator
    pdf_generator = PDFGenerator()
    
    try:
        pdf_path = pdf_generator.generate_mpv_booking(booking)
        return redirect(f'/static/generated/{pdf_path}')
    except Exception as e:
        flash(f'Error generating MPV PDF: {str(e)}', 'error')
        return redirect(url_for('booking.view', id=id))

@booking_bp.route('/api/customer/<int:customer_id>')
@login_required
def get_customer(customer_id):
    """API endpoint to get customer details"""
    customer = Customer.query.get_or_404(customer_id)
    return jsonify(customer.to_dict())

@booking_bp.route('/<int:booking_id>/pdf')
@login_required
def generate_booking_pdf(booking_id):
    """Generate Service Proposal PDF using Classic PDF Generator (like original sample)"""
    from services.classic_pdf_generator import ClassicPDFGenerator
    from flask import send_file, make_response
    
    try:
        # Force refresh from database
        db.session.expire_all()
        booking = Booking.query.get_or_404(booking_id)
        
        # Prepare complete booking data for Classic PDF
        booking_data = {
            'booking_id': booking.booking_reference,
            'guest_name': booking.party_name or (booking.customer.name if booking.customer else 'N/A'),
            'guest_email': booking.customer.email if booking.customer else 'N/A', 
            'guest_phone': booking.customer.phone if booking.customer else 'N/A',
            'tour_name': booking.description or booking.hotel_name or 'Tour Package',
            'booking_date': booking.created_at.strftime('%Y-%m-%d') if booking.created_at else 'N/A',
            'tour_date': booking.arrival_date.strftime('%Y-%m-%d') if booking.arrival_date else 'N/A',
            'start_date': booking.traveling_period_start.strftime('%Y-%m-%d') if booking.traveling_period_start else (booking.arrival_date.strftime('%Y-%m-%d') if booking.arrival_date else 'N/A'),
            'end_date': booking.traveling_period_end.strftime('%Y-%m-%d') if booking.traveling_period_end else (booking.departure_date.strftime('%Y-%m-%d') if booking.departure_date else 'N/A'),
            'pax': booking.total_pax or 1,
            'adults': booking.adults or booking.total_pax or 1,
            'children': booking.children or 0,
            'infants': booking.infants or 0,
            'price': float(booking.total_amount) if booking.total_amount else 0.0,
            'status': booking.status,
            'description': booking.description or '',
            'internal_note': booking.admin_notes or booking.internal_note or '',
            'daily_services': booking.daily_services or '',
            'guest_list': booking.guest_list or '',  # Add guest list data
            'customer_address': getattr(booking.customer, 'address', '') if booking.customer else '',
            'customer_nationality': getattr(booking.customer, 'nationality', '') if booking.customer else '',
            'reference': booking.booking_reference
        }
        
        # Get products for this booking from the products JSON field
        products = []
        booking_products = booking.get_products()
        if booking_products:
            for product_data in booking_products:
                products.append({
                    'name': product_data.get('name', 'Unknown Product'),
                    'quantity': product_data.get('quantity', 1),
                    'price': float(product_data.get('price', 0.0)),
                    'amount': float(product_data.get('amount', 0.0))
                })
        
        # Debug: Print products being used  
        print(f"üîç PDF Products for {booking.booking_reference} ({len(products)} items):")
        for i, product in enumerate(products, 1):
            print(f"  {i}. {product['name']} x{product['quantity']} = {product['price']:,.2f} (Amount: {product['amount']:,.2f})")
        
        # Generate PDF using Classic PDF Generator
        classic_generator = ClassicPDFGenerator()
        pdf_path = classic_generator.generate_pdf(
            booking_data, 
            products, 
            f'static/generated/classic_service_proposal_{booking.booking_reference}_{datetime.now().strftime("%Y%m%d_%H%M%S")}_{random.randint(10000, 99999)}.pdf'
        )
        
        if not pdf_path:
            flash('Error generating Classic PDF file', 'error')
            return redirect(url_for('admin.bookings'))
        
        # Create response with no-cache headers to prevent browser caching
        response = make_response(redirect(f'/static/generated/{os.path.basename(pdf_path)}'))
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
    except Exception as e:
        flash(f'Error generating Classic PDF: {str(e)}', 'error')
        return redirect(url_for('admin.bookings'))

@booking_bp.route('/generate/<int:booking_id>/service-proposal')
def generate_service_proposal_pdf(booking_id):
    """Generate Service Proposal PDF using Classic PDF Generator"""
    from services.classic_pdf_generator import ClassicPDFGenerator
    from flask import send_file, abort, Response, make_response
    
    # Force refresh from database
    db.session.expire_all()
    booking = Booking.query.get_or_404(booking_id)

    try:
        # Prepare complete booking data for WeasyPrint
        booking_data = {
            'booking_id': booking.booking_reference,
            'guest_name': booking.party_name or (booking.customer.name if booking.customer else 'N/A'),
            'customer_name': booking.customer.name if booking.customer else 'N/A',  # Add explicit customer_name
            'guest_email': booking.customer.email if booking.customer else 'N/A', 
            'guest_phone': booking.customer.phone if booking.customer else 'N/A',
            'tour_name': booking.description or booking.hotel_name or 'Tour Package',
            'booking_date': booking.created_at.strftime('%Y-%m-%d') if booking.created_at else 'N/A',
            'tour_date': booking.arrival_date.strftime('%Y-%m-%d') if booking.arrival_date else 'N/A',
            'start_date': booking.traveling_period_start.strftime('%Y-%m-%d') if booking.traveling_period_start else (booking.arrival_date.strftime('%Y-%m-%d') if booking.arrival_date else 'N/A'),
            'end_date': booking.traveling_period_end.strftime('%Y-%m-%d') if booking.traveling_period_end else (booking.departure_date.strftime('%Y-%m-%d') if booking.departure_date else 'N/A'),
            'pax': booking.total_pax or 1,
            'adults': booking.adults or booking.total_pax or 1,
            'children': booking.children or 0,
            'infants': booking.infants or 0,
            'price': float(booking.total_amount) if booking.total_amount else 0.0,
            'status': booking.status,
            'description': booking.description or '',
            'flight_info': booking.flight_info or '',  # Pass empty string instead of None
            'special_request': booking.special_request or '',  # Pass empty string instead of None
            'internal_note': booking.admin_notes or booking.internal_note or '',
            'daily_services': booking.daily_services or '',
            'guest_list': booking.get_guest_list_for_edit() or '',  # Use clean text method for PDF
            'customer_address': getattr(booking.customer, 'address', '') if booking.customer else '',
            'customer_nationality': getattr(booking.customer, 'nationality', '') if booking.customer else '',
            'reference': booking.booking_reference
        }
        
        # Get products for this booking from the products JSON field
        products = []
        booking_products = booking.get_products()
        if booking_products:
            for product_data in booking_products:
                products.append({
                    'name': product_data.get('name', 'Unknown Product'),
                    'quantity': product_data.get('quantity', 1),
                    'price': float(product_data.get('price', 0.0)),
                    'amount': float(product_data.get('amount', 0.0))
                })
        
        # Debug: Print products being used  
        print(f"üîç PDF Products for {booking.booking_reference} ({len(products)} items):")
        for i, product in enumerate(products, 1):
            print(f"  {i}. {product['name']} x{product['quantity']} = {product['price']:,.2f} (Amount: {product['amount']:,.2f})")
        
        # Generate PDF using Classic PDF Generator  
        classic_generator = ClassicPDFGenerator()
        
        # Use adaptive path for development vs production
        output_dir = "static/generated"
        os.makedirs(output_dir, exist_ok=True)
        
        pdf_path = classic_generator.generate_pdf(
            booking_data, 
            products, 
            f'{output_dir}/classic_service_proposal_{booking.booking_reference}_{datetime.now().strftime("%Y%m%d_%H%M%S")}_{random.randint(10000, 99999)}.pdf'
        )
        
        if pdf_path and os.path.exists(pdf_path):
            # Add aggressive cache-busting headers
            response = send_file(pdf_path, 
                               as_attachment=True, 
                               download_name=f"booking_{booking.booking_reference}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf",
                               mimetype='application/pdf')
            
            # Aggressive anti-cache headers
            response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'
            response.headers['Pragma'] = 'no-cache'
            response.headers['Expires'] = '-1'
            response.headers['Last-Modified'] = datetime.now().strftime('%a, %d %b %Y %H:%M:%S GMT')
            response.headers['ETag'] = f'"{datetime.now().timestamp()}"'
            
            return response
        else:
            abort(404, description="PDF file not found")
            
    except Exception as e:
        import traceback
        full_error = traceback.format_exc()
        logger.error(f"Error generating Classic PDF for booking {booking_id}: {str(e)}")
        logger.error(f"Full traceback: {full_error}")
        abort(500, description=f"Error generating PDF: {str(e)}")

@booking_bp.route('/generate/<int:booking_id>/service-proposal-png')
def generate_service_proposal_png(booking_id):
    """Generate PNG image from Service Proposal PDF using ClassicPDFGenerator"""
    from services.classic_pdf_generator import ClassicPDFGenerator
    from services.pdf_image import pdf_to_png_bytes_list, pdf_to_long_png_bytes
    from flask import send_file, abort, Response
    import io, os
    
    # Force refresh from database
    db.session.expire_all()
    booking = Booking.query.get_or_404(booking_id)
    
    try:
        # Use party_name instead of client_name
        customer = booking.customer if hasattr(booking, 'customer') else None
        guest_name = booking.party_name or (customer.name if customer else 'Guest')
        
        booking_data = {
            'booking_id': booking.booking_reference,
            'guest_name': guest_name,
            'customer_name': guest_name,
            'guest_phone': customer.phone if customer else '',
            'pax': booking.total_pax or 1,
            'adults': booking.adults or 0,
            'children': booking.children or 0,
            'infants': booking.infants or 0,
            'start_date': booking.traveling_period_start.strftime('%d %b %Y') if booking.traveling_period_start else '',
            'end_date': booking.traveling_period_end.strftime('%d %b %Y') if booking.traveling_period_end else '',
            'booking_date': booking.created_at.strftime('%d.%b.%Y') if booking.created_at else '',
            'status': booking.status or 'pending',
            'flight_info': booking.flight_info or '',
            'description': booking.description or '',
            'daily_services': booking.daily_services or '',
            'guest_list': booking.guest_list or '',
            'internal_note': booking.admin_notes or booking.internal_note or '',
            'tour_name': booking.description or booking.hotel_name or 'Tour Package',
            'reference': booking.booking_reference
        }
        
        # Get products for this booking from the products JSON field (like voucher generator)
        products = []
        booking_products = booking.get_products()
        if booking_products:
            for product_data in booking_products:
                products.append({
                    'name': product_data.get('name', 'Unknown Product'),
                    'quantity': product_data.get('quantity', 1),
                    'price': float(product_data.get('price', 0.0)),
                    'amount': float(product_data.get('amount', 0.0))
                })
        
        # Generate PDF using ClassicPDFGenerator (with products)
        classic_generator = ClassicPDFGenerator()
        pdf_path = classic_generator.generate_pdf(booking_data, products)
        
        if not pdf_path or not os.path.exists(pdf_path):
            abort(500, description="PDF generation failed")
        
        # Read PDF file as bytes
        try:
            with open(pdf_path, 'rb') as f:
                pdf_bytes = f.read()
        finally:
            # Clean up temporary PDF file
            if os.path.exists(pdf_path):
                os.remove(pdf_path)
        
        # Convert PDF to PNG (all pages)
        png_list = pdf_to_png_bytes_list(pdf_bytes, zoom=2.0)
        if not png_list:
            abort(500, description="PNG conversion failed")
        
        # Check if PDF has multiple pages
        if len(png_list) > 1:
            # Create long PNG with all pages stacked vertically
            png_bytes = pdf_to_long_png_bytes(pdf_bytes, zoom=2.0, page_spacing=30)
            if not png_bytes:
                # Fallback to first page if long PNG fails
                png_bytes = png_list[0]
        else:
            # Single page PDF
            png_bytes = png_list[0]
        
        # Return PNG image
        return Response(
            png_bytes,
            mimetype='image/png',
            headers={
                'Content-Disposition': f'inline; filename="booking_{booking.booking_reference}.png"',
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache',
                'Expires': '0'
            }
        )
            
    except Exception as e:
        logger.error(f"Error generating PNG: {str(e)}")
        abort(500, description=f"Error generating PNG: {str(e)}")


# ============================================================================
# Main PDF/PNG Generation Routes (Authentication Required)
# ============================================================================

@booking_bp.route('/<int:booking_id>/png')
@login_required
def generate_booking_png(booking_id):
    """Generate PNG image from Service Proposal PDF using Classic PDF Generator with PNG conversion"""
    from services.classic_pdf_generator import ClassicPDFGenerator
    from services.pdf_image import pdf_to_png_bytes_list
    from flask import send_file, abort, Response
    import io, os
    
    try:
        booking = Booking.query.get_or_404(booking_id)
        
        # Prepare complete booking data including guest_list
        guest_list = booking.guest_list if booking.guest_list else ''
        
        booking_data = {
            'booking_id': booking.booking_reference,
            'guest_name': booking.party_name or (booking.customer.name if booking.customer else 'N/A'),
            'guest_email': booking.customer.email if booking.customer else 'N/A', 
            'guest_phone': booking.customer.phone if booking.customer else 'N/A',
            'tour_name': booking.description or booking.hotel_name or 'Tour Package',
            'booking_date': booking.created_at.strftime('%Y-%m-%d') if booking.created_at else 'N/A',
            'tour_date': booking.arrival_date.strftime('%Y-%m-%d') if booking.arrival_date else 'N/A',
            'start_date': booking.traveling_period_start.strftime('%Y-%m-%d') if booking.traveling_period_start else (booking.arrival_date.strftime('%Y-%m-%d') if booking.arrival_date else 'N/A'),
            'end_date': booking.traveling_period_end.strftime('%Y-%m-%d') if booking.traveling_period_end else (booking.departure_date.strftime('%Y-%m-%d') if booking.departure_date else 'N/A'),
            'pax': booking.total_pax or 1,
            'adults': booking.adults or booking.total_pax or 1,
            'children': booking.children or 0,
            'infants': booking.infants or 0,
            'price': float(booking.total_amount) if booking.total_amount else 0.0,
            'status': booking.status,
            'description': booking.description or '',
            'internal_note': booking.admin_notes or booking.internal_note or '',
            'daily_services': booking.daily_services or '',
            'customer_address': getattr(booking.customer, 'address', '') if booking.customer else '',
            'customer_nationality': getattr(booking.customer, 'nationality', '') if booking.customer else '',
            'reference': booking.booking_reference,
            'guest_list': guest_list
        }
        
        # Get products for this booking from the products JSON field
        products = []
        booking_products = booking.get_products()
        if booking_products:
            for product_data in booking_products:
                products.append({
                    'name': product_data.get('name', 'Unknown Product'),
                    'quantity': product_data.get('quantity', 1),
                    'price': float(product_data.get('price', 0.0)),
                    'amount': float(product_data.get('amount', 0.0))
                })
        
        # Generate PDF using ClassicPDFGenerator first
        classic_generator = ClassicPDFGenerator()
        
        # Create temporary PDF file with adaptive path
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = "static/generated"
        os.makedirs(output_dir, exist_ok=True)
        pdf_filename = f'{output_dir}/temp_for_png_{booking.booking_reference}_{timestamp}.pdf'
        
        pdf_path = classic_generator.generate_pdf(booking_data, products, pdf_filename)
        
        if not pdf_path or not os.path.exists(pdf_path):
            flash('Error generating PDF for PNG conversion', 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Read PDF file as bytes
        try:
            with open(pdf_path, 'rb') as f:
                pdf_bytes = f.read()
        finally:
            # Clean up temporary PDF file
            if os.path.exists(pdf_path):
                os.remove(pdf_path)
        
        # Convert PDF to PNG (all pages)
        png_list = pdf_to_png_bytes_list(pdf_bytes, zoom=2.0)
        if not png_list:
            flash('Error converting PDF to PNG', 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Check if PDF has multiple pages
        if len(png_list) > 1:
            from services.pdf_image import pdf_to_long_png_bytes
            # Create long PNG with all pages stacked vertically
            png_bytes = pdf_to_long_png_bytes(pdf_bytes, zoom=2.0, page_spacing=30)
            if not png_bytes:
                # Fallback to first page if long PNG fails
                png_bytes = png_list[0]
        else:
            # Single page - use as is
            png_bytes = png_list[0]
        filename = f'booking_{booking.booking_reference}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.png'
        
        return Response(
            png_bytes,
            mimetype='image/png',
            headers={'Content-Disposition': f'attachment; filename="{filename}"'}
        )
            
    except Exception as e:
        flash(f'Error generating PNG: {str(e)}', 'error')
        return redirect(url_for('booking.view', id=booking_id))


# ============================================================================
# WeasyPrint PDF Generation Routes (Thai Font Support)
# ============================================================================

@booking_bp.route('/<int:booking_id>/pdf/weasyprint')
@login_required
def generate_booking_pdf_weasyprint(booking_id):
    """Generate Service Proposal PDF using Modern WeasyPrint (Enhanced Design & Thai Font Support)"""
    from services.weasyprint_generator_v2 import ModernWeasyPrintGenerator
    from flask import send_file, abort
    import os
    
    booking = Booking.query.get_or_404(booking_id)

    try:
        # Prepare complete booking data for WeasyPrint
        booking_data = {
            'booking_reference': booking.booking_reference,
            'status': booking.status,
            'customer_name': booking.customer.name if booking.customer else 'N/A',
            'customer_email': booking.customer.email if booking.customer else 'N/A',
            'customer_phone': booking.customer.phone if booking.customer else 'N/A',
            'customer_address': booking.customer.address if booking.customer and booking.customer.address else '',
            'customer_nationality': booking.customer.nationality if booking.customer and booking.customer.nationality else '',
            'adults': booking.adults or 0,
            'children': booking.children or 0,
            'infants': booking.infants or 0,
            'party_name': booking.party_name or '',
            'party_code': booking.party_code or '',
            'description': booking.description or '',
            'pickup_point': booking.pickup_point or '',
            'destination': booking.destination or '',
            'pickup_time': str(booking.pickup_time) if booking.pickup_time else '',
            'vehicle_type': booking.vehicle_type or '',
            'internal_note': booking.internal_note or '',
            'flight_info': booking.flight_info or '',
            'daily_services': booking.daily_services or '',
            'admin_notes': booking.admin_notes or '',
            'manager_memos': booking.manager_memos or '',
            'total_amount': float(booking.total_amount) if booking.total_amount else 0.0,
            'currency': booking.currency or 'THB',
            'time_limit': str(booking.time_limit) if booking.time_limit else '',
            'due_date': str(booking.due_date) if booking.due_date else '',
            'created_at': str(booking.created_at) if booking.created_at else '',
            'updated_at': str(booking.updated_at) if booking.updated_at else ''
        }
        
        # Get products (if any)
        products = []
        if hasattr(booking, 'products') and booking.products:
            try:
                import json
                products_data = json.loads(booking.products) if booking.products else []
                for product in products_data:
                    quantity = product.get('quantity', 1)
                    unit_price = float(product.get('price', 0))
                    products.append({
                        'description': product.get('name', 'Unknown Service'),
                        'quantity': quantity,
                        'unit_price': unit_price,
                        'total_price': quantity * unit_price
                    })
            except (json.JSONDecodeError, ValueError):
                # Fallback - create sample products
                products = [
                    {
                        'description': 'Tour Service (‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ß‡∏£‡πå)',
                        'quantity': booking.adults + booking.children,
                        'unit_price': 1500.00,
                        'total_price': (booking.adults + booking.children) * 1500.00
                    }
                ]
        
        # Generate PDF using Modern WeasyPrint
        weasyprint_generator = ModernWeasyPrintGenerator()
        pdf_path = weasyprint_generator.generate_service_proposal(
            booking_data=booking_data,
            products=products
        )
        
        if os.path.exists(pdf_path):
            return send_file(pdf_path, 
                           as_attachment=True, 
                           download_name=f"Service_Proposal_Thai_{booking.booking_reference}.pdf",
                           mimetype='application/pdf')
        else:
            flash('Error generating WeasyPrint PDF file', 'error')
            return redirect(url_for('booking.view', id=booking_id))
            
    except Exception as e:
        flash(f'Error generating WeasyPrint PDF: {str(e)}', 'error')
        return redirect(url_for('booking.view', id=booking_id))


@booking_bp.route('/<int:booking_id>/png/weasyprint')
@login_required
def generate_booking_png_weasyprint(booking_id):
    """Generate Service Proposal PNG using Modern WeasyPrint (Enhanced Design & Thai Font Support)"""
    from services.weasyprint_generator_v2 import ModernWeasyPrintGenerator
    from flask import send_file, abort
    import os
    
    booking = Booking.query.get_or_404(booking_id)

    try:
        # Prepare booking data for WeasyPrint
        booking_data = {
            'booking_reference': booking.booking_reference,
            'customer_name': booking.customer.name if booking.customer else 'N/A',
            'customer_email': booking.customer.email if booking.customer else 'N/A',
            'customer_phone': booking.customer.phone if booking.customer else 'N/A',
            'adults': booking.adults or 0,
            'children': booking.children or 0,
            'infants': booking.infants or 0,
            'admin_notes': booking.admin_notes or '',
            'manager_memos': booking.manager_memos or '',
            'internal_note': booking.internal_note or ''
        }
        
        # Get products (if any)
        products = []
        if hasattr(booking, 'products') and booking.products:
            try:
                import json
                products_data = json.loads(booking.products) if booking.products else []
                for product in products_data:
                    quantity = product.get('quantity', 1)
                    unit_price = float(product.get('price', 0))
                    products.append({
                        'description': product.get('name', 'Unknown Service'),
                        'quantity': quantity,
                        'unit_price': unit_price,
                        'total_price': quantity * unit_price
                    })
            except (json.JSONDecodeError, ValueError):
                # Fallback - create sample products
                products = [
                    {
                        'description': 'Tour Service (‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ß‡∏£‡πå)',
                        'quantity': booking.adults + booking.children,
                        'unit_price': 1500.00,
                        'total_price': (booking.adults + booking.children) * 1500.00
                    }
                ]
        
        # Generate PNG using Modern WeasyPrint
        weasyprint_generator = ModernWeasyPrintGenerator()
        png_path = weasyprint_generator.generate_service_proposal_png(
            booking_data=booking_data,
            products=products
        )
        
        if os.path.exists(png_path):
            return send_file(png_path, 
                           as_attachment=True, 
                           download_name=f"Service_Proposal_Thai_{booking.booking_reference}.png",
                           mimetype='image/png')
        else:
            flash('Error generating WeasyPrint PNG file', 'error')
            return redirect(url_for('booking.view', id=booking_id))
            
    except Exception as e:
        flash(f'Error generating WeasyPrint PNG: {str(e)}', 'error')
        return redirect(url_for('booking.view', id=booking_id))


@booking_bp.route('/generate/<int:booking_id>/service-proposal-png-weasyprint')
def generate_service_proposal_png_weasyprint(booking_id):
    """Generate Modern WeasyPrint PNG"""
    from services.weasyprint_generator_v2 import ModernWeasyPrintGenerator
    from flask import send_file, abort, Response
    import os
    from datetime import datetime
    import json
    
    booking = Booking.query.get_or_404(booking_id)

    try:
        # Prepare booking data for WeasyPrint
        booking_data = {
            'booking_reference': booking.booking_reference,
            'customer_name': booking.customer.name if booking.customer else 'N/A',
            'customer_email': booking.customer.email if booking.customer else 'N/A',
            'customer_phone': booking.customer.phone if booking.customer else 'N/A',
            'adults': booking.adults or 0,
            'children': booking.children or 0,
            'infants': booking.infants or 0,
            'admin_notes': booking.admin_notes or '',
            'manager_memos': booking.manager_memos or '',
            'internal_note': booking.internal_note or ''
        }
        
        # Get products (if any)
        products = []
        if hasattr(booking, 'products') and booking.products:
            try:
                products_data = json.loads(booking.products) if booking.products else []
                for product in products_data:
                    quantity = product.get('quantity', 1)
                    unit_price = float(product.get('price', 0))
                    products.append({
                        'description': product.get('name', 'Unknown Service'),
                        'quantity': quantity,
                        'unit_price': unit_price,
                        'total_price': quantity * unit_price
                    })
            except (json.JSONDecodeError, ValueError):
                # Fallback - create sample products
                products = [
                    {
                        'description': 'Tour Service (‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ß‡∏£‡πå)',
                        'quantity': booking.adults + booking.children,
                        'unit_price': 1500.00,
                        'total_price': (booking.adults + booking.children) * 1500.00
                    }
                ]
        
        # Generate PNG using Modern WeasyPrint
        weasyprint_generator = ModernWeasyPrintGenerator()
        png_path = weasyprint_generator.generate_service_proposal_png(
            booking_data=booking_data,
            products=products
        )
        
        if os.path.exists(png_path):
            return send_file(png_path, 
                           as_attachment=True, 
                           download_name=f"Service_Proposal_Thai_{booking.booking_reference}.png",
                           mimetype='image/png')
        else:
            abort(404, description="PNG file not found")
            
    except Exception as e:
        logger.error(f"Error generating PNG: {str(e)}")
        abort(500, description=f"Error generating PNG: {str(e)}")


@booking_bp.route('/generate/<int:booking_id>/service-proposal-weasyprint')
def generate_service_proposal_pdf_weasyprint(booking_id):
    """Generate Modern WeasyPrint PDF"""
    from services.tour_voucher_weasyprint import TourVoucherWeasyPrintGenerator
    from flask import send_file, abort, Response
    import os
    from datetime import datetime
    import json
    
    booking = Booking.query.get_or_404(booking_id)

    try:
        # Prepare booking data for WeasyPrint
        booking_data = {
            'booking_reference': booking.booking_reference,
            'customer_name': booking.customer.name if booking.customer else 'N/A',
            'customer_email': booking.customer.email if booking.customer else 'N/A',
            'customer_phone': booking.customer.phone if booking.customer else 'N/A',
            'adults': booking.adults or 0,
            'children': booking.children or 0,
            'infants': booking.infants or 0,
            'admin_notes': booking.admin_notes or '',
            'manager_memos': booking.manager_memos or '',
            'internal_note': booking.internal_note or ''
        }
        
        # Sample products for testing with enhanced structure
        products = [
            {
                'description': 'Bangkok City Tour (‡∏ó‡∏±‡∏ß‡∏£‡πå‡πÄ‡∏°‡∏∑‡∏≠‡∏á‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û‡∏Ø)',
                'quantity': booking.adults or 2,
                'unit_price': 1500.00,
                'total_price': (booking.adults or 2) * 1500.00
            },
            {
                'description': 'Temple Visit (‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°‡∏ä‡∏°‡∏ß‡∏±‡∏î)',
                'quantity': (booking.adults or 2) + (booking.children or 1),
                'unit_price': 800.00,
                'total_price': ((booking.adults or 2) + (booking.children or 1)) * 800.00
            },
            {
                'description': 'Thai Lunch (‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÑ‡∏ó‡∏¢‡∏Å‡∏•‡∏≤‡∏á‡∏ß‡∏±‡∏ô)',
                'quantity': (booking.adults or 2) + (booking.children or 1),
                'unit_price': 400.00,
                'total_price': ((booking.adults or 2) + (booking.children or 1)) * 400.00
            }
        ]
        
        # Generate PDF using Tour Voucher WeasyPrint
        weasyprint_generator = TourVoucherWeasyPrintGenerator()
        pdf_path = weasyprint_generator.generate_tour_voucher(booking)
        
        if os.path.exists(pdf_path):
            # Add cache-busting headers
            response = send_file(pdf_path, 
                               as_attachment=True, 
                               download_name=f"WeasyPrint_Thai_{booking.booking_reference}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf",
                               mimetype='application/pdf')
            
            # Anti-cache headers
            response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'
            response.headers['Pragma'] = 'no-cache'
            response.headers['Expires'] = '-1'
            response.headers['Last-Modified'] = datetime.now().strftime('%a, %d %b %Y %H:%M:%S GMT')
            response.headers['ETag'] = f'"{datetime.now().timestamp()}"'
            
            return response
        else:
            return f"Error: PDF file not found at {pdf_path}", 500
            
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        return f"Error generating WeasyPrint PDF: {str(e)}\n\nDetails:\n{error_details}", 500

# ===========================
# ENHANCED WORKFLOW ROUTES
# ===========================

@booking_bp.route('/<int:booking_id>/confirm', methods=['POST'])
@login_required
def confirm_booking(booking_id):
    """Step 2: Confirm booking (from pending to confirmed)"""
    try:
        booking = Booking.query.get_or_404(booking_id)
        
        if booking.status != 'pending':
            message = f'Booking must be in pending status to confirm. Current status: {booking.status}'
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'message': message}), 400
            flash(message, 'warning')
            return redirect(url_for('booking.view', id=booking_id))
        
        booking.confirm_booking()
        db.session.commit()
        
        logger.info(f"‚úÖ Booking {booking.booking_reference} confirmed")
        
        # Return JSON for AJAX requests
        if request.is_json or request.headers.get('Content-Type') == 'application/json':
            return jsonify({
                'success': True,
                'message': f'Booking {booking.booking_reference} confirmed! Ready to create quote.',
                'status': booking.status,
                'confirmed_at': booking.confirmed_at.isoformat() if booking.confirmed_at else None
            })
        
        # Regular form submission
        flash(f'Booking {booking.booking_reference} confirmed! Ready to create quote.', 'success')
        return redirect(url_for('booking.view', id=booking_id))
        
    except Exception as e:
        logger.error(f"Error confirming booking {booking_id}: {str(e)}")
        error_message = f'Error confirming booking: {str(e)}'
        
        # Return JSON for AJAX requests
        if request.is_json or request.headers.get('Content-Type') == 'application/json':
            return jsonify({'success': False, 'message': error_message}), 500
        
        # Regular form submission
        flash(error_message, 'error')
        return redirect(url_for('booking.view', id=booking_id))

@booking_bp.route('/<int:booking_id>/create-quote', methods=['POST'])
@login_required
def create_quote_workflow(booking_id):
    """Step 2: Create Quote (QT) with PDF/PNG"""
    try:
        logger.info(f"üéØ Starting create_quote_workflow for booking {booking_id}")
        
        # Check if booking exists first
        booking = Booking.query.filter_by(id=booking_id).first()
        if not booking:
            message = f'Booking {booking_id} not found'
            logger.error(f"‚ùå {message}")
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'message': message}), 404
            flash(message, 'error')
            return redirect(url_for('booking.list'))
        
        # Force refresh SQLAlchemy metadata for quotes table
        from extensions import db
        from models.quote import Quote
        logger.info("üîÑ Refreshing SQLAlchemy metadata...")
        db.metadata.reflect(bind=db.engine, only=['quotes'])
        
        logger.info(f"üìã Booking {booking_id} loaded, status: {booking.status}")
        
        if not booking.can_create_quote():
            message = 'Booking must be confirmed before creating quote'
            logger.warning(f"‚ùå Cannot create quote: {message} (current status: {booking.status})")
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'message': message}), 400
            flash(message, 'warning')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Check if quote already exists
        logger.info("üîç Checking for existing quotes...")
        
        # Use raw SQL to avoid SQLAlchemy metadata issues
        try:
            result = db.session.execute(
                db.text("SELECT id, quote_number FROM quotes WHERE booking_id = :booking_id"), 
                {"booking_id": booking_id}
            ).fetchone()
            
            if result:
                message = f'Quote {result.quote_number} already exists'
                logger.info(f"‚ÑπÔ∏è  Found existing quote: {result.quote_number}")
                if request.is_json or request.headers.get('Content-Type') == 'application/json':
                    return jsonify({
                        'success': False, 
                        'message': message,
                        'quote_id': result.id,
                        'quote_number': result.quote_number
                    }), 400
                flash(message, 'info')
                return redirect(url_for('quote.view_quote', quote_id=result.id))
                
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è  Raw SQL check failed: {e}, continuing with creation")
        
        # Check if quote service is available
        if not QUOTE_SERVICE_AVAILABLE or QuoteService is None:
            message = 'Quote service is not available'
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'message': message}), 500
            flash(message, 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Create quote using service
        quote_service = QuoteService()
        quote_id = quote_service.create_quote_from_booking(booking)
        
        # Update booking status
        booking.mark_as_quoted()
        db.session.commit()
        
        # Get the quote using raw SQL to avoid metadata issues
        quote_result = db.session.execute(
            db.text("SELECT quote_number FROM quotes WHERE id = :quote_id"), 
            {"quote_id": quote_id}
        ).fetchone()
        
        quote_number = quote_result.quote_number if quote_result else f"QT{quote_id}"
        
        logger.info(f"‚úÖ Quote {quote_number} created for booking {booking.booking_reference}")
        
        # Return JSON for AJAX requests
        if request.is_json or request.headers.get('Content-Type') == 'application/json':
            return jsonify({
                'success': True,
                'message': f'Quote {quote_number} created! PDF/PNG available for download.',
                'quote_number': quote_number,
                'quote_id': quote_id,
                'status': booking.status,
                'quoted_at': booking.quoted_at.isoformat() if booking.quoted_at else None
            })
        
        # Regular form submission
        flash(f'Quote {quote_number} created! PDF/PNG available for download.', 'success')
        return redirect(url_for('quote.view_quote', quote_id=quote_id))
        
    except Exception as e:
        logger.error(f"Error creating quote for booking {booking_id}: {str(e)}")
        error_message = f'Error creating quote: {str(e)}'
        if request.is_json or request.headers.get('Content-Type') == 'application/json':
            return jsonify({'success': False, 'message': error_message}), 500
        flash(error_message, 'error')
        return redirect(url_for('booking.view', id=booking_id))

@booking_bp.route('/<int:booking_id>/apply-to-invoice', methods=['POST'])
@login_required
def apply_to_invoice_workflow(booking_id):
    """Step 3: Apply Quote to Invoice (AR)"""
    try:
        booking = Booking.query.get_or_404(booking_id)
        
        # Check if booking can apply to invoice (status should be quoted)
        if booking.status != 'quoted':
            message = 'Booking must be quoted before applying to invoice'
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'message': message}), 400
            flash(message, 'warning')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Get quote using raw SQL to avoid SQLAlchemy metadata issues
        try:
            quote_result = db.session.execute(
                db.text("SELECT id, quote_number, status FROM quotes WHERE booking_id = :booking_id"), 
                {"booking_id": booking_id}
            ).fetchone()
            
            if not quote_result:
                message = 'No quote found for this booking'
                if request.is_json or request.headers.get('Content-Type') == 'application/json':
                    return jsonify({'success': False, 'message': message}), 400
                flash(message, 'warning')
                return redirect(url_for('booking.view', id=booking_id))
                
        except Exception as e:
            logger.error(f"Error fetching quote: {e}")
            message = f'Error fetching quote: {str(e)}'
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'message': message}), 500
            flash(message, 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        quote_id = quote_result.id
        quote_number = quote_result.quote_number
        quote_status = quote_result.status
        
        # Accept quote first if not already accepted
        if quote_status != 'accepted':
            db.session.execute(
                db.text("UPDATE quotes SET status = 'accepted' WHERE id = :quote_id"),
                {"quote_id": quote_id}
            )
            
        # Convert quote to invoice using existing Invoice Ninja integration
        booking_invoice_service = BookingInvoiceService()
        invoice_data = booking_invoice_service.create_invoice_from_booking(booking)
        
        if invoice_data:
            # Mark invoice as paid immediately (as requested)
            booking.invoice_number = invoice_data.get('number')
            booking.invoice_status = 'paid'
            booking.is_paid = True
            booking.invoice_paid_date = datetime.utcnow()
            
            # Mark quote as converted using raw SQL
            db.session.execute(
                db.text("UPDATE quotes SET converted_to_invoice = 1 WHERE id = :quote_id"),
                {"quote_id": quote_id}
            )
            
            # Update booking status
            booking.mark_as_paid()
            db.session.commit()
            
            logger.info(f"‚úÖ Quote {quote_number} applied to Invoice {booking.invoice_number}")
            
            # Return JSON for AJAX requests
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({
                    'success': True,
                    'message': f'Quote applied to Invoice {booking.invoice_number} (Status: Paid)! Ready to generate voucher.',
                    'invoice_number': booking.invoice_number,
                    'status': booking.status,
                    'paid_at': booking.invoice_paid_date.isoformat() if booking.invoice_paid_date else None
                })
            
            flash(f'Quote applied to Invoice {booking.invoice_number} (Status: Paid)! Ready to generate voucher.', 'success')
        else:
            # Return JSON for AJAX requests
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'message': 'Error creating invoice from quote'}), 500
            flash('Error creating invoice from quote', 'error')
            
        return redirect(url_for('booking.view', id=booking_id))
        
    except Exception as e:
        logger.error(f"Error applying to invoice for booking {booking_id}: {str(e)}")
        error_message = f'Error applying to invoice: {str(e)}'
        if request.is_json or request.headers.get('Content-Type') == 'application/json':
            return jsonify({'success': False, 'message': error_message}), 500
        flash(error_message, 'error')
        return redirect(url_for('booking.view', id=booking_id))

@booking_bp.route('/<int:booking_id>/generate-voucher', methods=['POST'])
@login_required
def generate_voucher_workflow(booking_id):
    """Step 4: Generate Tour Voucher PDF/PNG"""
    try:
        booking = Booking.query.get_or_404(booking_id)
        
        if not booking.can_generate_voucher():
            message = 'Invoice must be paid before generating voucher'
            if request.is_json or request.headers.get('Content-Type') == 'application/json':
                return jsonify({'success': False, 'message': message}), 400
            flash(message, 'warning')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Generate voucher using TourVoucherGeneratorV2
        from services.tour_voucher_generator_v2 import TourVoucherGeneratorV2
        generator = TourVoucherGeneratorV2()
        pdf_filename = generator.generate_tour_voucher_v2(booking)
        
        # Update booking status
        booking.mark_as_vouchered()
        db.session.commit()
        
        logger.info(f"‚úÖ Voucher generated for booking {booking.booking_reference}")
        
        # Return JSON for AJAX requests
        if request.is_json or request.headers.get('Content-Type') == 'application/json':
            return jsonify({
                'success': True,
                'message': 'Tour Voucher generated! PDF/PNG available for download and sharing.',
                'booking_reference': booking.booking_reference,
                'status': booking.status,
                'vouchered_at': booking.vouchered_at.isoformat() if booking.vouchered_at else None,
                'pdf_filename': pdf_filename
            })
        
        flash(f'Tour Voucher generated! PDF/PNG available for download and sharing.', 'success')
        
        return redirect(url_for('voucher.view_voucher', booking_id=booking_id))
        
    except Exception as e:
        logger.error(f"Error generating voucher for booking {booking_id}: {str(e)}")
        error_message = f'Error generating voucher: {str(e)}'
        if request.is_json or request.headers.get('Content-Type') == 'application/json':
            return jsonify({'success': False, 'message': error_message}), 500
        flash(error_message, 'error')
        return redirect(url_for('booking.view', id=booking_id))

@booking_bp.route('/api/<int:booking_id>/quote-id')
@login_required
def get_quote_id_by_booking(booking_id):
    """API endpoint to get quote_id by booking_id"""
    try:
        booking = Booking.query.get_or_404(booking_id)
        quote = Quote.query.filter_by(booking_id=booking_id).first()
        
        if quote:
            return jsonify({'quote_id': quote.id, 'quote_number': quote.quote_number})
        else:
            return jsonify({'quote_id': None, 'message': 'No quote found for this booking'}), 404
            
    except Exception as e:
        logger.error(f"Error getting quote ID for booking {booking_id}: {str(e)}")
        return jsonify({'error': str(e)}), 500

@booking_bp.route('/api/<int:booking_id>/mark-paid', methods=['POST'])
def api_mark_as_paid(booking_id):
    """Enhanced API endpoint to mark booking as paid with payment details"""
    try:
        booking = Booking.query.get_or_404(booking_id)
        
        # Get payment data from request
        data = request.get_json()
        
        # Server-side validation
        errors = []
        
        # Validate received_date
        received_date_str = data.get('received_date')
        if not received_date_str:
            errors.append('‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏')
        else:
            try:
                # Parse Thai date format DD/MM/YYYY
                received_date = datetime.strptime(received_date_str, '%d/%m/%Y').date()
                if received_date > datetime.now().date():
                    errors.append('‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï')
            except ValueError:
                errors.append('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö ‡∏ß‡∏ß/‡∏î‡∏î/‡∏õ‡∏õ‡∏õ‡∏õ)')
        
        # Validate product_type
        product_type = data.get('product_type')
        allowed_product_types = ['air_ticket', 'package', 'tour', 'live_ticket', 'other']
        if not product_type or product_type not in allowed_product_types:
            errors.append('‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£')
        
        # Validate bank_name
        bank_name = data.get('bank_name')
        allowed_banks = ['BBL', 'KBank', 'KTB', 'SCB', 'Krungsri', 'TTB', 'KKP', 'CIMB', 'UOB', 'GHB', 'GSB', 'LH']
        if not bank_name or bank_name not in allowed_banks:
            errors.append('‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£')
        
        # Validate amount
        amount = data.get('amount')
        if not amount:
            errors.append('‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏')
        else:
            try:
                amount_float = float(str(amount).replace(',', ''))
                if amount_float <= 0:
                    errors.append('‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0')
                # Check decimal places
                decimal_places = len(str(amount_float).split('.')[-1]) if '.' in str(amount_float) else 0
                if decimal_places > 2:
                    errors.append('‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏°‡∏µ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 2 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á')
            except (ValueError, TypeError):
                errors.append('‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á')
        
        # Validate details (optional)
        details = data.get('details', '').strip()
        if len(details) > 1000:
            errors.append('‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 1,000 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£')
        
        # Return validation errors
        if errors:
            return jsonify({'success': False, 'errors': errors}), 400
        
        # Check booking status
        if booking.status != 'quoted':
            return jsonify({
                'success': False, 
                'error': f'‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏î‡πâ Booking ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Quoted ‡∏Å‡πà‡∏≠‡∏ô (‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: {booking.status})'
            }), 400
        
        # Update booking with payment details
        booking.status = 'paid'
        booking.is_paid = True
        booking.invoice_paid_date = datetime.now()
        
        # Store payment details (you may need to add these fields to your Booking model)
        if hasattr(booking, 'payment_received_date'):
            booking.payment_received_date = received_date
        if hasattr(booking, 'payment_product_type'):
            booking.payment_product_type = product_type
        if hasattr(booking, 'payment_bank_name'):
            booking.payment_bank_name = bank_name
        if hasattr(booking, 'payment_amount'):
            booking.payment_amount = amount_float
        if hasattr(booking, 'payment_details'):
            booking.payment_details = details
        
        # Update paid timestamp if method exists
        if hasattr(booking, 'mark_as_paid'):
            booking.mark_as_paid()
        
        db.session.commit()
        
        logger.info(f"‚úÖ Booking {booking_id} marked as paid with amount {amount_float} THB via {bank_name}")
        
        return jsonify({
            'success': True, 
            'message': f'‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß! ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô {amount_float:,.2f} ‡∏ö‡∏≤‡∏ó ‡∏ú‡πà‡∏≤‡∏ô {bank_name}',
            'status': booking.status,
            'is_paid': booking.is_paid,
            'paid_at': booking.invoice_paid_date.isoformat() if booking.invoice_paid_date else None
        })
        
    except Exception as e:
        logger.error(f"Error marking booking {booking_id} as paid: {str(e)}")
        return jsonify({'success': False, 'error': f'‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}'}), 500

# ========== ENHANCED BOOKING ACTIONS ==========

@booking_bp.route('/<int:booking_id>/enhanced-pdf')
@login_required
def generate_enhanced_booking_pdf(booking_id):
    """Generate enhanced booking PDF with workflow status and sharing capabilities"""
    try:
        from flask import send_from_directory
        
        booking = Booking.query.get_or_404(booking_id)
        
        # Generate enhanced PDF
        pdf_generator = BookingPDFGenerator()
        pdf_path, png_path = pdf_generator.generate_booking_pdf(booking, booking.customer, getattr(booking, 'vendor', None))
        
        # Update booking with document paths
        booking.pdf_path = pdf_path
        booking.png_path = png_path
        
        # Create sharing package
        share_service = PublicShareService()
        document_data = {
            'customer_name': booking.customer.full_name,
            'booking_reference': booking.booking_reference,
            'status': booking.status
        }
        
        sharing_package = share_service.create_shareable_content('booking', booking, document_data)
        
        db.session.commit()
        
        # Send PDF file
        directory = os.path.dirname(pdf_path)
        filename = os.path.basename(pdf_path)
        
        logger.info(f"‚úÖ Enhanced booking PDF generated: {pdf_path}")
        flash(f'‚úÖ Enhanced booking document generated with sharing capabilities!')
        
        return send_from_directory(directory, filename, as_attachment=True)
        
    except Exception as e:
        logger.error(f"Error generating enhanced booking PDF {booking_id}: {str(e)}")
        flash('‚ùå Error generating enhanced booking document')
        return redirect(url_for('booking.view', id=booking_id))

@booking_bp.route('/<int:booking_id>/confirm-enhanced', methods=['POST'])
@login_required
def confirm_booking_enhanced(booking_id):
    """Confirm booking and move to next workflow step - Enhanced version"""
    try:
        from utils.datetime_utils import naive_utc_now
        
        booking = Booking.query.get_or_404(booking_id)
        
        if booking.status != Booking.STATUS_DRAFT:
            flash('‚ùå Booking is not in draft status')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Update booking status
        booking.status = Booking.STATUS_CONFIRMED
        booking.confirmed_at = naive_utc_now()
        
        db.session.commit()
        
        flash(f'‚úÖ Booking {booking.booking_reference} confirmed! Ready for quote generation.')
        logger.info(f"Booking {booking.booking_reference} confirmed")
        
        return redirect(url_for('booking.view', id=booking_id))
        
    except Exception as e:
        logger.error(f"Error confirming booking {booking_id}: {str(e)}")
        db.session.rollback()
        flash('‚ùå Error confirming booking')
        return redirect(url_for('booking.view', id=booking_id))


# ===========================
# QUOTE PDF/PNG GENERATION ROUTES  
# ===========================

@booking_bp.route('/<int:booking_id>/quote-pdf')
@login_required
def generate_quote_pdf(booking_id):
    """Generate Quote PDF for booking when status is 'quoted', 'paid', or 'vouchered' - Real-time Data Sync"""
    try:
        # ‚≠ê REAL-TIME DATA SYNC: ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å database ‡πÅ‡∏ö‡∏ö force refresh
        from extensions import db
        from services.universal_booking_extractor import UniversalBookingExtractor
        
        # Clear any cached data and force fresh query
        db.session.close()
        
        # Get fresh booking data using Universal Extractor
        booking = UniversalBookingExtractor.get_fresh_booking_data(booking_id)
        if not booking:
            flash('‚ùå Booking not found', 'error')
            return redirect(url_for('dashboard.bookings'))
            
        logger.info(f'Generating Quote PDF for booking {booking.booking_reference} (Real-time sync)')
        logger.info(f'Booking status: {booking.status}')
        
        if booking.status not in ['quoted', 'paid', 'vouchered']:
            flash('‚ùå Quote PDF only available for quoted, paid, or vouchered bookings', 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Import Working Template Generator (uses quote_template_final.html)
        from services.working_template_generator import WorkingTemplateGenerator
        
        quote_generator = WorkingTemplateGenerator()
        pdf_filename = quote_generator.generate_quote_pdf(booking.id)
        
        # Generate PDF path
        output_dir = os.path.join('static', 'generated')
        pdf_path = os.path.join(output_dir, pdf_filename)
        
        if os.path.exists(pdf_path):
            logger.info(f'Quote PDF generated successfully: {pdf_filename}')
            
            # Generate download filename with latest update timestamp
            from datetime import datetime
            current_time = datetime.now()
            # Format: Quote_BK20250922O8NP_20250922_124530.pdf (Latest Update)
            date_stamp = current_time.strftime('%Y%m%d')
            time_stamp = current_time.strftime('%H%M%S')
            download_name = f"Quote_{booking.booking_reference}_{date_stamp}_{time_stamp}.pdf"
            
            return send_file(pdf_path, 
                           as_attachment=True, 
                           download_name=download_name,
                           mimetype='application/pdf')
        else:
            flash('‚ùå Error generating Quote PDF', 'error')
            return redirect(url_for('booking.view', id=booking_id))
            
    except Exception as e:
        logger.error(f"Error generating Quote PDF for booking {booking_id}: {str(e)}")
        flash('‚ùå Error generating Quote PDF', 'error')
        return redirect(url_for('booking.view', id=booking_id))


@booking_bp.route('/<int:booking_id>/quote-png')  
@login_required
def generate_quote_png(booking_id):
    """Generate Quote PNG (multi-page) for booking when status is 'quoted', 'paid', or 'vouchered' - Real-time Data Sync"""
    try:
        # ‚≠ê REAL-TIME DATA SYNC: ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å database ‡πÅ‡∏ö‡∏ö force refresh
        from extensions import db
        from services.universal_booking_extractor import UniversalBookingExtractor
        
        # Clear any cached data and force fresh query
        db.session.close()
        
        # Get fresh booking data using Universal Extractor
        booking = UniversalBookingExtractor.get_fresh_booking_data(booking_id)
        if not booking:
            flash('‚ùå Booking not found', 'error')
            return redirect(url_for('dashboard.bookings'))
            
        logger.info(f'Generating Quote PNG for booking {booking.booking_reference} (Real-time sync)')
        
        if booking.status not in ['quoted', 'paid', 'vouchered']:
            flash('‚ùå Quote PNG only available for quoted, paid, or vouchered bookings', 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Import required modules
        # Import Working Template Generator (uses quote_template_final.html)
        from services.working_template_generator import WorkingTemplateGenerator
        from services.pdf_image import pdf_to_long_png_bytes
        import fitz  # PyMuPDF
        
        # Generate Quote PDF first using real-time data with FRESH booking
        quote_generator = WorkingTemplateGenerator()
        pdf_filename = quote_generator.generate_quote_pdf(booking.id)  # Uses proper booking ID
        
        # Generate PDF path
        output_dir = os.path.join('static', 'generated')
        pdf_path = os.path.join(output_dir, pdf_filename)
        
        if not os.path.exists(pdf_path):
            flash('‚ùå Error generating Quote PDF for PNG conversion', 'error')
            return redirect(url_for('booking.view', id=booking_id))
        
        # Read PDF file as bytes
        with open(pdf_path, 'rb') as f:
            pdf_bytes = f.read()
        
        # Convert PDF to PNG (multi-page support)
        try:
            # Try to create long PNG with all pages stacked vertically
            png_bytes = pdf_to_long_png_bytes(pdf_bytes, zoom=2.0, page_spacing=30)
            if not png_bytes:
                # Fallback to first page only
                doc = fitz.open(pdf_path)
                page = doc.load_page(0)
                mat = fitz.Matrix(2, 2)  # 2x zoom
                pix = page.get_pixmap(matrix=mat)
                png_bytes = pix.tobytes("png")
                doc.close()
        except Exception as e:
            logger.warning(f"Multi-page PNG failed, using single page: {str(e)}")
            # Fallback to first page only
            doc = fitz.open(pdf_path)
            page = doc.load_page(0)
            mat = fitz.Matrix(2, 2)  # 2x zoom  
            pix = page.get_pixmap(matrix=mat)
            png_bytes = pix.tobytes("png")
            doc.close()
        
        # Generate filename with latest update timestamp: Quote_BK20250922O8NP_20250922_151030.png
        from datetime import datetime
        current_time = datetime.now()
        date_stamp = current_time.strftime('%Y%m%d')
        time_stamp = current_time.strftime('%H%M%S')
        filename = f'Quote_{booking.booking_reference}_{date_stamp}_{time_stamp}.png'
        
        return Response(
            png_bytes,
            mimetype='image/png',
            headers={'Content-Disposition': f'attachment; filename="{filename}"'}
        )
            
    except Exception as e:
        logger.error(f"Error generating Quote PNG for booking {booking_id}: {str(e)}")
        flash('‚ùå Error generating Quote PNG', 'error')
        return redirect(url_for('booking.view', id=booking_id))

# Email PDF Routes
@booking_bp.route('/<int:booking_id>/email-pdf', methods=['GET', 'POST'])
@login_required
def email_booking_pdf(booking_id):
    """Send booking PDF via email"""
    booking = Booking.query.get_or_404(booking_id)
    
    if request.method == 'POST':
        recipient_email = request.form.get('email', '').strip()
        
        if not recipient_email:
            flash('‚ùå Email address is required', 'error')
            return redirect(url_for('booking.email_booking_pdf', booking_id=booking_id))
        
        try:
            # Generate PDF first
            from services.weasyprint_generator import WeasyPrintGenerator
            generator = WeasyPrintGenerator()
            
            # Prepare booking data dict
            booking_data = {
                'booking_reference': booking.booking_reference,
                'customer_name': booking.customer.full_name if booking.customer else 'N/A',
                'customer_email': booking.customer.email if booking.customer else '',
                'customer_phone': booking.customer.phone if booking.customer else '',
                'adults': booking.adults or 0,
                'children': booking.children or 0,
                'infants': booking.infants or 0,
                'admin_notes': booking.admin_notes or '',
                'manager_memos': booking.manager_memos or '',
                'internal_note': booking.internal_note or ''
            }
            
            # Get products/services
            products = []
            if hasattr(booking, 'products') and booking.products:
                for product in booking.products:
                    # Handle product as object, dict, or str
                    if hasattr(product, 'name'):
                        name = product.name
                        description = getattr(product, 'description', '') or ''
                        price = getattr(product, 'price', 0) or 0
                    elif isinstance(product, dict):
                        name = product.get('name', '')
                        description = product.get('description', '')
                        price = product.get('price', 0)
                    else:
                        name = str(product)
                        description = ''
                        price = 0
                    products.append({
                        'name': name,
                        'description': description,
                        'price': price,
                        'quantity': 1
                    })
            
            # Generate PDF
            pdf_path = generator.generate_service_proposal(booking_data, products)
            
            if pdf_path and os.path.exists(pdf_path):
                # Send email
                from services.email_service import EmailService
                email_service = EmailService()
                email_service.send_booking_pdf(recipient_email, pdf_path, booking)
                
                # Clean up temporary file
                os.unlink(pdf_path)
                
                flash(f'‚úÖ Booking PDF sent successfully to {recipient_email}', 'success')
                return redirect(url_for('booking.view', id=booking_id))
            else:
                flash('‚ùå Error generating booking PDF', 'error')
                
        except Exception as e:
            logger.error(f"Error sending booking PDF email: {str(e)}")
            flash(f'‚ùå Error sending email: {str(e)}', 'error')
    
    # GET request - show form
    return render_template('booking/email_pdf_form.html', 
                         booking=booking, 
                         pdf_type='booking',
                         action_url=url_for('booking.email_booking_pdf', booking_id=booking_id))

@booking_bp.route('/<int:booking_id>/email-quote-pdf', methods=['GET', 'POST'])
@login_required
def email_quote_pdf(booking_id):
    """Send quote PDF via email"""
    booking = Booking.query.get_or_404(booking_id)
    
    if request.method == 'POST':
        recipient_email = request.form.get('email', '').strip()
        
        if not recipient_email:
            flash('‚ùå Email address is required', 'error')
            return redirect(url_for('booking.email_quote_pdf', booking_id=booking_id))
        
        try:
            # Generate PDF first
            from services.weasyprint_quote_generator import WeasyPrintQuoteGenerator
            generator = WeasyPrintQuoteGenerator()
            pdf_filename = generator.generate_quote_pdf(booking)
            
            if pdf_filename and os.path.exists(pdf_filename):
                # Send email
                from services.email_service import EmailService
                email_service = EmailService()
                email_service.send_quote_pdf(recipient_email, pdf_filename, booking)
                
                # Clean up temporary file
                os.unlink(pdf_filename)
                
                flash(f'‚úÖ Quote PDF sent successfully to {recipient_email}', 'success')
                return redirect(url_for('booking.view', id=booking_id))
            else:
                flash('‚ùå Error generating quote PDF', 'error')
                
        except Exception as e:
            logger.error(f"Error sending quote PDF email: {str(e)}")
            flash(f'‚ùå Error sending email: {str(e)}', 'error')
    
    # GET request - show form
    return render_template('booking/email_pdf_form.html', 
                         booking=booking, 
                         pdf_type='quote',
                         action_url=url_for('booking.email_quote_pdf', booking_id=booking_id))


@booking_bp.route('/cancel/<int:booking_id>', methods=['POST'])
@login_required
def cancel_booking(booking_id):
    """Cancel a booking by setting status to cancelled"""
    try:
        booking = Booking.query.get_or_404(booking_id)
        
        # Check if booking can be cancelled
        if booking.status == 'cancelled':
            flash('‚ùå Booking is already cancelled', 'warning')
            return redirect(url_for('booking.view', id=booking_id))
            
        # Update booking status to cancelled
        booking.status = 'cancelled'
        booking.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        flash(f'‚úÖ Booking {booking.booking_reference} has been cancelled successfully', 'success')
        logger.info(f"Booking {booking.booking_reference} cancelled by user {current_user.username}")
        
        return redirect(url_for('booking.view', id=booking_id))
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error cancelling booking {booking_id}: {str(e)}")
        flash(f'‚ùå Error cancelling booking: {str(e)}', 'error')
        return redirect(url_for('booking.view', id=booking_id))


@booking_bp.route('/<int:booking_id>/pending', methods=['POST'])
@login_required
def pending_booking(booking_id):
    """Move booking from draft to pending status"""
    try:
        booking = Booking.query.get_or_404(booking_id)
        
        # Check if booking can be moved to pending
        if booking.status != 'draft':
            return jsonify({
                'success': False,
                'message': f'Booking must be in draft status to move to pending. Current status: {booking.status}'
            })
            
        # Update booking status to pending
        booking.status = 'pending'
        booking.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        logger.info(f"Booking {booking.booking_reference} moved to pending status by user {current_user.username}")
        
        return jsonify({
            'success': True,
            'message': f'Booking {booking.booking_reference} moved to pending status successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error moving booking {booking_id} to pending: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error moving booking to pending: {str(e)}'
        })
